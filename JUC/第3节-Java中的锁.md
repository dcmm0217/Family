# 第3节-Java中的锁

## 1、乐观锁和悲观锁

#### 1.1 悲观锁

悲观锁认为自己在使用数据的时候一定有别的线程来修改数据，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改。

**synchronized关键字和Lock的实现类都是悲观锁**

使用场景：适合写多读少的场景，先加锁确保写操作时数据正确，显式锁定后再操作同步资源。

#### 1.2 乐观锁

乐观锁认为自己在使用数据时==不会有别的线程修改数据==，所以不会加锁，只是在更新数据的时候去判断之前有没有别的线程更新了这个数据。

如果这个数据没有被更新，当前线程将自己的修改的数据成功写入。如果数据已经被其他线程修改，则根据不同实现方式去执行不同的操作。

乐观锁在Java中是通过无锁编程来实现，**最常采用的是CAS算法，Java原子类中的递增操作就是通过CAS自旋实现的。**

使用场景：适合读操作多的场景，不加锁的特点能够使其读操作的性能大幅提升。乐观锁则直接去操作同步资源，是一种无锁算法，得之我幸不得我命，再抢

乐观锁一般有两种实现方式：

1、采用版本号机制

2、CAS（Compare-and-Swap，即比较并替换）算法实现

