# Java中的锁机制

## 1、公平锁和非公平锁

#### 1、定义

公平锁：是指多个线程按照申请锁的顺序来获取锁，类似于排队买饭，先来后到，先来先服务，就是公平的，也就是队列

非公平锁：是指多个线程获取锁的顺序，并不是按照申请锁的顺序，有可能申请的线程比先申请的线程优先获取锁，在高并发环境下，有可能造成优先级翻转，或者饥饿的线程（也就是某个线程一直得不到锁）

#### 2、如何创建

并发包中ReentrantLock的创建可以指定析构函数的boolean类型来得到公平锁或者非公平锁，默认是非公平锁

```java
/**
* 创建一个可重入锁，true 表示公平锁，false 表示非公平锁。默认非公平锁
*/
Lock lock = new ReentrantLock(true);
```

**公平锁**：就是很公平，在并发环境中，每个线程在获取锁时会先查看此锁维护的等待队列，如果为空，或者当前线程是等待队列中的第一个，就占用锁，否者就会加入到等待队列中，以后安装FIFO的规则从队列中取到自己

**非公平锁：** 非公平锁比较粗鲁，上来就直接尝试占有锁，如果尝试失败，就再采用类似公平锁那种方式。

Java ReentrantLock通过构造函数指定该锁是否公平，默认是非公平锁，因为非公平锁的优点在于吞吐量比公平锁大，`对于synchronized而言，也是一种非公平锁`

**可重入锁的整体架构图**

![image-20211029141020131](https://gitee.com/huangwei0123/image/raw/master/img/image-20211029141020131.png)

```java
在ReentrantLock中，它对AbstractQueuedSynchronizer的state状态值定义为线程获取该锁的重入次数，
    state状态值为0表示当前没有被任何线程持有，state状态值为1表示被其他线程持有，
    因为支持可重入，如果是持有锁的线程，再次获取同一把锁，直接成功，并且state状态值+1，线程释放锁state状态值-1，同理重入多次锁的线程，需要释放相应的次数。
```

**非公平锁获取资源**/释放资源

```java
/**
 * 非公平-获取资源
 */
final boolean nonfairTryAcquire(int acquires) {
    //获取当前线程
    final Thread current = Thread.currentThread();
    //获取当前状态
    int c = getState();
    if (c == 0) { // state==0 代表资源可获取
        //cas设置state为acquires，acquires传入的是1
        if (compareAndSetState(0, acquires)) {
            //cas成功，设置当前持有锁的线程
            setExclusiveOwnerThread(current);
            //返回成功
            return true;
        }
    }
    else if (current == getExclusiveOwnerThread()) { //如果state!=0,但是当前线程是持有锁线程，直接重入
        //state状态+1
        int nextc = c + acquires;
        if (nextc < 0) // overflow
            throw new Error("Maximum lock count exceeded");
        //设置state状态，此处不需要cas，因为持有锁的线程只有一个    
        setState(nextc);
        //返回成功
        return true;
    }
    //返回失败
    return false;
}

/**
 * 释放资源
 */
protected final boolean tryRelease(int releases) {
    //state状态-releases，releases传入的是1
    int c = getState() - releases;
    if (Thread.currentThread() != getExclusiveOwnerThread()) //如果当前线程不是持有锁线程，抛出异常
        throw new IllegalMonitorStateException();
    //设置返回状态，默认为失败
    boolean free = false;
    if (c == 0) {//state-1后，如果c==0代表释放资源成功
        //返回状态设置为true
        free = true;
        //清空持有锁线程
        setExclusiveOwnerThread(null);
    }
    //如果state-1后，state还是>0，代表当前线程有锁重入操作，需要做相应的释放次数，设置state值
    setState(c);
    return free;
}
```

**nonfairTryAcquire，非公平锁加锁流程**

![image-20211029141721567](https://gitee.com/huangwei0123/image/raw/master/img/image-20211029141721567.png)

**fairTryAcquire公平锁，上锁流程**

![image-20211029141934925](https://gitee.com/huangwei0123/image/raw/master/img/image-20211029141934925.png)



**入CLH队列策略**

![image-20211029142012023](https://gitee.com/huangwei0123/image/raw/master/img/image-20211029142012023.png)

#### AQS的整个流程图

## ![image-20211029142202190](https://gitee.com/huangwei0123/image/raw/master/img/image-20211029142202190.png)2、可重入锁和递归锁

可重入锁就是递归锁

**指的是同一线程外层函数获得锁之后，内层递归函数仍然能获取到该锁的代码，在同一线程在外层方法获取锁的时候，在进入内层方法会自动获取锁**

=== 也就是说：`线程可以进入任何一个它已经拥有的锁所同步的代码块` ===

ReentrantLock / Synchronized 就是一个典型的可重入锁

```java
public synchronized void method1() {
	method2();
}

public synchronized void method2() {

}
```

可重入锁就是，在一个method1方法中加入一把锁，方法2也加锁了，那么他们拥有的是同一把锁

也就是说我们只需要进入method1后，那么它也能直接进入method2方法，因为他们所拥有的锁，是同一把。

=== 作用： === 可重入锁最大的作用就是避免死锁

#### 1、可重入验证

**证明Synchronized**

```java
class Phone{
    public synchronized void sendSMS(){
        System.out.println(Thread.currentThread().getName() + "\t invoked sendSMS()");

        // 在同步方法中，调用另外一个同步方法
        sendEmail();
    }

    public synchronized void sendEmail(){
        System.out.println(Thread.currentThread().getName() + "\t invoked sendEmail()");
    }
}

public class ReenterLockDemo {
    public static void main(String[] args) {
        Phone phone = new Phone();
        new Thread(phone::sendSMS,"t1").start();
        new Thread(phone::sendSMS,"t2").start();
    }

}
```

在这里，我们编写了一个资源类phone，拥有两个加了synchronized的同步方法，分别是sendSMS 和 sendEmail，我们在sendSMS方法中，调用sendEmail。最后在主线程同时开启了两个线程进行测试，最后得到的结果为：

```java
t1	 invoked sendSMS()
t1	 invoked sendEmail()
t2	 invoked sendSMS()
t2	 invoked sendEmail()
```

这就说明当 t1 线程进入sendSMS的时候，拥有了一把锁，同时t2线程无法进入，直到t1线程拿着锁，执行了sendEmail 方法后，才释放锁，这样t2才能够进入

```java
t1	 invoked sendSMS()      t1线程在外层方法获取锁的时候
t1	 invoked sendEmail()    t1在进入内层方法会自动获取锁

t2	 invoked sendSMS()      t2线程在外层方法获取锁的时候
t2	 invoked sendEmail()    t2在进入内层方法会自动获取锁
```

**证明ReentrantLock**

```java
class Phone implements Runnable {
    
    Lock lock = new ReentrantLock();

    public void getLock() {
        lock.lock();
        try {
            System.out.println(Thread.currentThread().getName() + "\t get Lock");
            setLock();
        } catch (Exception e) {
            e.printStackTrace();
        }finally {
            lock.unlock();
        }
    }

    public void setLock(){
        lock.lock();
        try {
            System.out.println(Thread.currentThread().getName() + "\t set Lock");
        } catch (Exception e) {
            e.printStackTrace();
        }finally {
            lock.unlock();
        }
    }

    @Override
    public void run() {
        getLock();
    }
}

public class ReenterLockDemo {
    public static void main(String[] args) {
        Phone phone = new Phone();
        new Thread(phone,"AA").start();
        new Thread(phone,"BB").start();
    }

}
```

最后输出结果我们能发现，结果和加synchronized方法是一致的，都是在外层的方法获取锁之后，线程能够直接进入里层

```
t3	 get Lock
t3	 set Lock
t4	 get Lock
t4	 set Lock
```

**当我们在getLock方法加两把锁会是什么情况呢？**  (阿里面试)

```java
public void getLock() {
    lock.lock();
    lock.lock();
    try {
        System.out.println(Thread.currentThread().getName() + "\t get Lock");
        setLock();
    } finally {
        lock.unlock();
        lock.unlock();
    }
}
```

最后得到的结果也是一样的，因为里面不管有几把锁，其它他们都是同一把锁，也就是说用同一个钥匙都能够打开

**当我们在getLock方法加两把锁，但是只解一把锁会出现什么情况呢？**

```java
public void getLock() {
    lock.lock();
    lock.lock();
    try {
        System.out.println(Thread.currentThread().getName() + "\t get Lock");
        setLock();
    } finally {
        lock.unlock();
        lock.unlock();
    }
}

t3	 get Lock
t3	 set Lock
```

也就是说程序直接卡死，线程不能出来，也就说明我们申请几把锁，最后需要解除几把锁

**当我们只加一把锁，但是用两把锁来解锁的时候，又会出现什么情况呢？**

```java
public void getLock() {
    lock.lock();
    try {
        System.out.println(Thread.currentThread().getName() + "\t get Lock");
        setLock();
    } finally {
        lock.unlock();
        lock.unlock();
    }
}
```

这个时候，运行程序会直接报错

```
t3	 get Lock
t3	 set Lock
t4	 get Lock
t4	 set Lock
Exception in thread "t3" Exception in thread "t4" java.lang.IllegalMonitorStateException
	at java.util.concurrent.locks.ReentrantLock$Sync.tryRelease(ReentrantLock.java:151)
	at java.util.concurrent.locks.AbstractQueuedSynchronizer.release(AbstractQueuedSynchronizer.java:1261)
	at java.util.concurrent.locks.ReentrantLock.unlock(ReentrantLock.java:457)
	at com.moxi.interview.study.thread.Phone.getLock(ReenterLockDemo.java:52)
	at com.moxi.interview.study.thread.Phone.run(ReenterLockDemo.java:67)
	at java.lang.Thread.run(Thread.java:745)
java.lang.IllegalMonitorStateException
	at java.util.concurrent.locks.ReentrantLock$Sync.tryRelease(ReentrantLock.java:151)
	at java.util.concurrent.locks.AbstractQueuedSynchronizer.release(AbstractQueuedSynchronizer.java:1261)
	at java.util.concurrent.locks.ReentrantLock.unlock(ReentrantLock.java:457)
	at com.moxi.interview.study.thread.Phone.getLock(ReenterLockDemo.java:52)
	at com.moxi.interview.study.thread.Phone.run(ReenterLockDemo.java:67)
	at java.lang.Thread.run(Thread.java:745)
```

## 3、自旋锁

自旋锁：spinLock，**是指尝试获取锁的线程不会立即阻塞，而是采用循环的方式尝试去获取锁**，这样的好处就是减少线程上下文切换的消耗，缺点是循环会消耗CPU资源

**原来提到的CAS底层就是自旋**，自旋就是多次尝试，多次访问，不会阻塞的状态就是自旋。

![image-20211029171520742](https://gitee.com/huangwei0123/image/raw/master/img/image-20211029171520742.png)

#### 1、优缺点

优：循环比较直到获取成功为止，没有类似wait的阻塞

缺：当不断自旋的线程越来越多的时候，会因为不断执行while循环而CPU资源性能

#### 2、手写自旋锁

通过CAS操作完成自旋锁，A线程先进来调用myLock方法自己持有锁5s，B随机进来发现当前线程持有锁，不是null，所以只能通过自旋等待，直到A释放后，B随后抢到

```java
public class SpinLockDemo {

    // 现在的泛型装的是Thread，原子引用线程
    AtomicReference<Thread> atomicReference = new AtomicReference<>();

    public void myLock() {
        Thread thread = Thread.currentThread();
        System.out.println(Thread.currentThread().getName() + "\t come in ");
        while (!atomicReference.compareAndSet(null, thread)) {
        }

    }

    public void myUnLock() {
        Thread thread = Thread.currentThread();
        atomicReference.compareAndSet(thread, null);
        System.out.println(Thread.currentThread().getName() + "\t invoked myUnlock()");
    }


    public static void main(String[] args) {

        SpinLockDemo spinLockDemo = new SpinLockDemo();

        new Thread(() -> {
            spinLockDemo.myLock();
            try {
                TimeUnit.SECONDS.sleep(5);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }finally {
                spinLockDemo.myUnLock();
            }
        },"t1").start();

        try {
            TimeUnit.SECONDS.sleep(1);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        new Thread(()->{
            spinLockDemo.myLock();
            spinLockDemo.myUnLock();
        },"t2").start();

    }
}

```

```java
t1 come in
.....一秒后.....
t2 come in
.....五秒后.....
t1 invoked myUnlock()
t2 invoked myUnlock()
```

首先输出的是 t1	 come in 

然后1秒后，t2线程启动，发现锁被t1占有，所有不断的执行 compareAndSet方法，来进行比较，直到t1释放锁后，也就是5秒后，t2成功获取到锁，然后释放