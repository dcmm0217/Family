# 查询优化以及索引优化

## 1、数据准备

学员表 插 50万 条， 班级表 插 1万 条

**步骤1：建表**

```sql
CREATE TABLE `class` (
  `id` INT (11) NOT NULL AUTO_INCREMENT,
  `className` VARCHAR (30) DEFAULT NULL,
  `address` VARCHAR (40) DEFAULT NULL,
  `monitor` INT NULL,
  PRIMARY KEY (`id`)
) ENGINE = INNODB AUTO_INCREMENT = 1 DEFAULT CHARSET = utf8;

CREATE TABLE `student` (`id` INT (11) NOT NULL AUTO_INCREMENT,
`stuno` INT NOT NULL,
`name` VARCHAR (20) DEFAULT NULL,
`age` INT (3) DEFAULT NULL,
`classId` INT (11) DEFAULT NULL,
PRIMARY KEY (`id`) #CONSTRAINT `fk_class_id` FOREIGN KEY (`classId`) REFERENCES `t_class` (`id`) 
) ENGINE=INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;
```

**步骤2：设置参数**

- 命令开启：允许创建函数设置：

```sql
# 不加global只是当前窗口有效。
set global log_bin_trust_function_creators=1; 
```

**步骤3：创建函数**

```sql
#随机产生字符串 
DELIMITER //

CREATE FUNCTION rand_string (n INT) RETURNS VARCHAR (255)
BEGIN
  DECLARE chars_str VARCHAR (100) DEFAULT 'abcdefghijklmnopqrstuvwxyzABCDEFJHIJKLMNOPQRSTUVWXYZ';
  DECLARE return_str VARCHAR (255) DEFAULT '';
  DECLARE i INT DEFAULT 0;
  WHILE
    i < n DO SET return_str = CONCAT (
      return_str,
      SUBSTRING (chars_str, FLOOR (1+ RAND () * 52), 1)
    );
    SET i = i + 1;
  END WHILE;
  RETURN return_str;
END //

DELIMITER;

#假如要删除
# drop function rand_string;
```

随机产生班级编号

```sql
#用于随机产生多少到多少的编号 
DELIMITER //

CREATE FUNCTION rand_num (from_num INT, to_num INT) RETURNS INT (11)
BEGIN
  DECLARE i INT DEFAULT 0;
  SET i = FLOOR (
    from_num + RAND () * (to_num - from_num + 1)
  );
  RETURN i;
END //

DELIMITER;
#假如要删除
# drop function rand_string;
```

**步骤4：创建存储过程**

```sql
#创建往stu表中插入数据的存储过程
DELIMITER //

CREATE PROCEDURE insert_stu (START INT, max_num INT)
BEGIN
  DECLARE i INT DEFAULT 0;
  SET autocommit = 0;
  REPEAT
    SET i = i + 1;
    INSERT INTO student (stuno, NAME, age, classId)
    VALUES
      (
        (START + i),
        rand_string (6),
        rand_num (1, 50),
        rand_num (1, 1000)
      );
    UNTIL i = max_num
  END REPEAT;
  COMMIT;
END //

DELIMITER;
#drop PROCEDURE insert_stu;
```

创建往class表中插入数据的存储过程

```sql
#执行存储过程，往class表添加随机数据 
 DELIMITER //

CREATE PROCEDURE `insert_class` (max_num INT)
BEGIN
  DECLARE i INT DEFAULT 0;
  SET autocommit = 0;
  REPEAT
    SET i = i + 1;
    INSERT INTO class (classname, address, monitor)
    VALUES
      (
        rand_string (8),
        rand_string (10),
        rand_num (1, 100000)
      );
    UNTIL i = max_num
  END REPEAT;
  COMMIT;
END //

DELIMITER;
#drop PROCEDURE insert_stu;
```

**步骤5：调用存储过程**

class

```sql
#执行存储过程，往class表添加1万条数据 
CALL insert_class(10000);
```

stu

```sql
#执行存储过程，往stu表添加50万条数据 
CALL insert_stu(100000,500000);
```

**步骤6：删除某表上的索引**

创建存储过程

```sql
DELIMITER //

CREATE PROCEDURE `proc_drop_index` (
  dbname VARCHAR (200),
  tablename VARCHAR (200)
)
BEGIN
  DECLARE done INT DEFAULT 0;
  DECLARE ct INT DEFAULT 0;
  DECLARE _index VARCHAR (200) DEFAULT '';
  DECLARE _cur CURSOR FOR
  SELECT
    index_name
  FROM
    information_schema.STATISTICS
  WHERE table_schema = dbname
    AND table_name = tablename
    AND seq_in_index = 1
    AND index_name <> 'PRIMARY';
  #每个游标必须使用不同的declare continue handler for not found set done=1来控制游标的结束 
   DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = 2;
  #若没有数据返回,程序继续,并将变量done设为2 
   OPEN _cur;
  FETCH _cur INTO _index;
  WHILE
    _index <> '' DO SET @str = CONCAT (
      "drop index ",
      _index,
      " on ",
      tablename
    );
    PREPARE sql_str FROM @str;
    EXECUTE sql_str;
    DEALLOCATE PREPARE sql_str;
    SET _index = '';
    FETCH _cur INTO _index;
  END WHILE;
  CLOSE _cur;
END //

DELIMITER;

# 执行存储过程
CALL proc_drop_index("dbname","tablename");
```

## 2、索引失效案例

#### 2.1 全值匹配我最爱

==where子句中出现的所有字段，都会去匹配索引。找到使用索引的最优解。==

系统中经常出现的sql语句如下：

```sql
EXPLAIN select sql_no_cache * from student where age = 30;
EXPLAIN select sql_no_cache * from student where age = 30 and classId = 4;
EXPLAIN select sql_no_cache * from student where age = 30 and classId = 4 and name = 'abcd';
```

建立索引前执行：（关注时间）

```mysql
mysql> EXPLAIN select sql_no_cache * from student where age = 30 and classId = 4 and name = 'abcd';
Empty set , 1 warning(0.28 sec) 
```

建立索引

```sql
create index idx_age on student(age);

create index idx_age_classId on student(age,classId);

create index idx_age_classId_name on student(age,classId,name);
```

可以看到，创建索引前查询时间是0.28秒，创建索引后的查询时间是0.01s,有效利用索引，可以帮我们极大的提升查询效率。



#### 2.2 最左前缀法则

在MySQL建立联合索引时，会遵守最佳左前缀匹配原则，即最左优先匹配原则，在检索数据时，从联合索引的最左边开始匹配。

eg1：

```sql
EXPLAIN select sql_no_cache * from student where student.age=30 and student.name = 'abcd';
```

eg2：

```sql
EXPLAIN select sql_no_cache * from student where student.classId=1 and student.name = 'abcd';
```

eg3：索引idx_age_classId_name还能正常使用？

```sql
EXPLAIN select sql_no_cache * from student where classId = 4 and  student.age=30 and student.name = 'abcd';
```

==如果索引了多列，就要遵守最左前缀原则，指的是查询从索引的最左列开始并且不跳过索引中的列。==

```sql
EXPLAIN select sql_no_cache * from student where student.age=30 and student.name = 'abcd';
```

![image-20220125124556343](https://gitee.com/huangwei0123/image/raw/master/img/image-20220125124556343.png)

虽然可以被正常使用，但是只有部分被使用到了。

```sql
EXPLAIN select sql_no_cache * from student where classId=1 and name = 'abcd';
```

![image-20220125124705242](https://gitee.com/huangwei0123/image/raw/master/img/image-20220125124705242.png)

因为缺少了联合索引的最左列，所以没有使用上索引。

结论：Mysql可以为多个字段创建索引，一个索引包括16个字段。==对于联合索引，过滤条件要使用索引必须按照索引建立时的顺序，依次满足，一旦跳过某个字段，索引后的字段都无法被使用。如果查询的条件中没有使用到这些字段中的第一个字段时，联合索引将不会被使用。==

> 扩展：Alibaba 《java开发手册》
>
> 索引文件具有B-tree的最左前缀匹配特性，如果左边的值未确定，那么无法使用此索引

#### 2.3 主键插入顺序

对于一个使用innoDB存储引擎的表来说，在我们没有显示的创建索引时，表中的数据实际上都是存储在`聚簇索引`的叶子节点上的。

而记录又是存储在数据页中的，数据页和记录又是按照记录`主键值从小到大`的顺序进行排序，所以如果我们`插入`的记录的==主键值是依次增大==的话，那么我们每插满一个数据页就换到下一个数据页继续插，而==如果我们插入的主键值忽大忽小的话，就可能出现页分裂的情况==。

![image-20220125134858726](https://gitee.com/huangwei0123/image/raw/master/img/image-20220125134858726.png)

如果此时再插入一条数据为9的记录，那它插入的位置就如下图所示

![image-20220125135016802](https://gitee.com/huangwei0123/image/raw/master/img/image-20220125135016802.png)

可能这个数据页已经满了，再插进来怎么办呢？**我们需要把当前页面分裂成两个页面，把本页中的一些记录移动到新创建的这个页中。页面分裂和记录移位意味着什么？**

==就意味着：**性能消耗**！==

==所以我们想尽量避免这样无谓的性能损耗，最好让插入的记录**主键值依次递增**，这样就不会发生这样的性能损耗了。==所以我们建议，让主键具有auto_increment，让存储引擎自己为表生成主键，而不是我们手动插入，比如`person_info`表

```sql
CREATE TABLE person_info (
  id INT UNSIGNED NOT NULL AUTO_INCREMENT,
  NAME VARCHAR (100) NOT NULL,
  birthday DATE NOT NULL,
  phone_number CHAR (11) NOT NULL,
  country VARCHAR (100) NOT NULL,
  PRIMARY KEY (id),
  KEY idx_name_birthday_phone_number (NAME (10), birthday, phone_number)
);
```

我们自定义的**主键列 id 拥有 AUTO_INCREMENT 属性**，==在插入记录时存储引擎会自动为我们填入自增的主键值。这样的主键占用空间小，顺序写入，减少页分裂。==

#### 2.4 计算、函数、类型转换（自动|手动）导致索引失效

1、这两种sql哪种写法更好

```sql
EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE student.name LIKE 'abc%';

EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE LEFT(student.name,3) = 'abc';
```

2、创建索引

```sql
CREATE INDEX idx_name ON student(NAME);
```

第一种：索引优化生效

```sql
EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE student.name LIKE 'abc%';
```

![image-20220125144723745](https://gitee.com/huangwei0123/image/raw/master/img/image-20220125144723745.png)

第二种：索引失效

```sql
EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE LEFT(student.name,3) = 'abc';
```

![image-20220125144831515](https://gitee.com/huangwei0123/image/raw/master/img/image-20220125144831515.png)

==索引列上不能使用函数==

再举例：

student表的字段stuno上设置有索引

```sql
CREATE INDEX idx_sno ON student(stuno);
```

```sql
EXPLAIN SELECT SQL_NO_CACHE id, stuno, NAME FROM student WHERE stuno+1 = 900001;
```

![image-20220125145128948](https://gitee.com/huangwei0123/image/raw/master/img/image-20220125145128948.png)

索引优化生效：

```sql
EXPLAIN SELECT SQL_NO_CACHE id, stuno, NAME FROM student WHERE stuno = 900000;
```

==索引列上不能有计算==

再举例：

student表的字段name上设置有索引

```sql
CREATE INDEX idx_name ON student(NAME);
```

```sql
EXPLAIN SELECT id, stuno, name FROM student WHERE SUBSTRING(name, 1,3)='abc';
```

![image-20220125145400300](https://gitee.com/huangwei0123/image/raw/master/img/image-20220125145400300.png)

```sql
EXPLAIN SELECT id, stuno, NAME FROM student WHERE NAME LIKE 'abc%';
```

![image-20220125145416196](https://gitee.com/huangwei0123/image/raw/master/img/image-20220125145416196.png)

#### 2.5 类型转型导致索引失效

下列哪个sql可以使用到索引（假设name字段上设置有索引）

```sql
# 未使用到索引
EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE name=123;
```

![image-20220125145743727](https://gitee.com/huangwei0123/image/raw/master/img/image-20220125145743727.png)

```sql
# 使用到索引 
EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE name='123';
```

![image-20220125145807357](https://gitee.com/huangwei0123/image/raw/master/img/image-20220125145807357.png)

==name=123发生类型转换，索引失效。==

#### 2.6 范围条件右边的列索引失效

```sql
ALTER TABLE student DROP INDEX idx_name; 

ALTER TABLE student DROP INDEX idx_age;

ALTER TABLE student DROP INDEX idx_age_classid;

EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE student.age=30 AND student.classId>20 AND student.name = 'abc' ;
```

![image-20220125152609268](https://gitee.com/huangwei0123/image/raw/master/img/image-20220125152609268.png)

那么索引，idx_age_classId_name，这个索引还能正常使用么?

- 不能，范围右边的列不能使用 比如 ==(<)，（<=）,（>），(>=)和between等范围条件==
- **如果出现这种SQL，应该建立,将使用范围查找的字段放到最后**

```sql
create index idx_age_name_classid on student(age,name,classid);
```

将范围查询条件放置语句最后：

```sql
EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE student.age=30 AND student.name = 'abc' AND student.classId>20 ;
```

![image-20220125152644724](https://gitee.com/huangwei0123/image/raw/master/img/image-20220125152644724.png)

> 应用开发中范围查询，例如，金额查询，日期查询往往都是范围查询。应该将查询条件防止where语句最后
>
> （创建的联合索引中，务必把范围涉及到的字段写在最后）



#### 2.7 不等于（!= | <> ）索引失效

- 为name字段创建索引

```sql
create index idx_name on student(name);
```

- 查看索引是否失效

```sql
explain select sql_no_cache * from student where name <> 'abc'
```

![image-20220125154324177](https://gitee.com/huangwei0123/image/raw/master/img/image-20220125154324177.png)

或者

```sql
explain select sql_no_cache * from student where name != 'abc'
```

**场景举例：用户踢出需求，将财务数据，产品利润金额不等于0的都统计出来。**

#### 2.8 is null 可以使用索引，is not null 无法使用索引

- is null：可以触发索引

```sql
explain select sql_no_cache * from student where age is null;
```

![image-20220125154650575](https://gitee.com/huangwei0123/image/raw/master/img/image-20220125154650575.png)

- is not null ：不能触发索引

```sql
explain select sql_no_cache * from student where age is not null;
```

![image-20220125154716684](https://gitee.com/huangwei0123/image/raw/master/img/image-20220125154716684.png)

==结论：最好在设计表的时候就将字段设置为 not null 约束==

比如你可以将int类型的字段，默认值设置为0，将字符类型的默认值设置为空字符串（''）

==扩展：同理，在查询中使用not like 也无法使用索引，导致全表扫描==

#### 2.9 like以通配符%开头索引失效

在使用like关键字的查询语句中，如果匹配字符串的第一个字符为"%"，索引就不会起作用，只有"%"不在第一个位置，索引才会起作用。

- 使用到索引

```sql
explain select sql_no_cache * from student where name like 'ab%';
```

![image-20220125155254433](https://gitee.com/huangwei0123/image/raw/master/img/image-20220125155254433.png)

- 未使用到索引

```sql
explain select sql_no_cache * from student where name like '%ab%';
```

![image-20220125155324462](https://gitee.com/huangwei0123/image/raw/master/img/image-20220125155324462.png)

> 扩展：Alibaba《Java手册》
>
> 【强制】页面搜索严禁左模糊或者全模糊，如果需要请走搜索引擎模块解决（一般互联网都使用ES，原理是倒排索引）

#### 2.10 OR前后存在非索引的列，索引失效

在Where子句中，如果在OR 前的条件列进行了索引，而在OR后的条件列没有进行索引，那么索引也会失效。==也就是说，OR前后的两个条件中的列都是索引时，查询中才会使用索引。==

 因为OR的含义就是两个只要满足一个条件即可，**因此只有一个条件列进行了索引是没有意义的，只要有条件列没有进行索引，就会进行全表扫描，因此索引列也会失效。**

查询语句使用OR关键字的情况

```sql
# 未使用到索引
explain select sql_no_cache * from student where age = 10 OR classid = 100;
```

![image-20220125162629935](https://gitee.com/huangwei0123/image/raw/master/img/image-20220125162629935.png)

**因为calssid字段没有索引，所以导致上述查询语句没有使用到索引。**

```sql
# 使用到索引
explain select sql_no_cache * from student where age = 10 OR name = 'Abel';
```

![image-20220125162933450](https://gitee.com/huangwei0123/image/raw/master/img/image-20220125162933450.png)

因为age字段和name字段上都有索引，所以查询中使用了索引，你能看道这里使用了`index_merge`，简单来说index_merge，就是对age和name属性分部进行了扫描，然后将这两个结果集进行了合并。这样做的好处就是`避免了全表扫描`。



#### 2.11 数据库和表的字符集统一使用utf8mb4

统一使用uft8bm4(5.5版本以上才支持)兼容性更好，统一字符集可以避免由于字符集转换产生的乱码。不同的字符集进行比较前需要进行转换，导致索引失效。



#### 2.12 总结

一般性建议：

- 对于单列索引，尽量选择针对当前query过滤性更好的字段进行索引
- 在选择组合索引的时候，当前query中过滤性最好的字段在索引字段顺序中，位置越靠前越好。
- 在选择组合索引的时候，尽量选择能够包含当前query中的where子句中更多字段的索引。（区分度越高）
- 在选择组合索引的时候，如果某个字段可能出现范围查询时，尽量把这个字段放在索引次序的最后面。

==**总之，写SQL时，尽量避免造成索引失效的情况。**==

## 3、关联查询优化

#### 3.1 数据准备

![image-20220125172119233](https://gitee.com/huangwei0123/image/raw/master/img/image-20220125172119233.png)

#### 3.2 采用左外连接

下面开始EXPLAIN分析

```sql
EXPLAIN select sql_no_cache * from type left join book on type.card = book.card;

#在外连接中，左边的表 叫驱动表，右边的表叫做被驱动表
```

![image-20220125173906263](https://gitee.com/huangwei0123/image/raw/master/img/image-20220125173906263.png)

添加索引

```sql
create index idx_book_card on book(card); 

create index idx_type_card on book(card); 

# 如果类型不一致，可以去掉其中一个表得索引。
```

左连接特性决定： 

==**left join条件用于确定如何从右表搜索行，左边一定都有，所以`右边是我们的关键点，一定需要建立索引`**==

![image-20220125173918533](https://gitee.com/huangwei0123/image/raw/master/img/image-20220125173918533.png)

#### 3.3 采用内连接

换成inner join（Mysql会自动选择驱动表）

```sql
explain select sql_no_cache * from type inner join book on type.card = book.card;
```

![image-20220125174423122](https://gitee.com/huangwei0123/image/raw/master/img/image-20220125174423122.png)

添加索引优化

```sql
create index idx_book_card on book(card); 

create index idx_type_card on book(card); 
```

![image-20220125174911277](https://gitee.com/huangwei0123/image/raw/master/img/image-20220125174911277.png)

**结论：**

- 对于**内连接**来说，查询优化器是可以决定谁作为驱动表，谁作为被驱动表出现的。（explain的结果上面是驱动表，下面的是被驱动表）

- 对于**内连接**来说，连接条件中**只有一个字段有索引**，==则有索引的字段所在的表会被作为**被驱动表**==。

- ==对于**内连接**来说，在两个表的连接条件都存在索引的情况下，会选择小表作为驱动表。对应一个优化原则（小表驱动大表）==，小表就是扫描查询成本比较低的表



#### 3.4 join语句原理

join方式连接多个表，本质就是各个表之间数据的循环匹配。Mysql5.5版本之前，Mysql只支持一种表间关联方式，就是嵌套循环（Nested Loop Join）。如果关联表的数据量很大，则join关联的执行时间会非常长。在Mysql5.5以后的版本中，Mysql通过引入BNLJ算法来优化嵌套执行。

##### **1、驱动表与被驱动表**

驱动表就是主表，被驱动表就是从表、非驱动表。

- 对于内连接来说

```sql
select * from A join B ON ....
```

A一定是驱动表吗？不一定，优化器会根据你查询语句做优化，决定先查哪张表。**先查询的那张表就是驱动表，反之就是被驱动表。通过explain关键字可以查看。**

- 对于外连接来说

```sql
select * from A left join B ON .... 

select * from B right join A ON .... 
```

通常，==大家会认为A就是驱动表，B就是被驱动表。但也未必==。测试如下：(**查询优化器会选择查询成本最小的表作为驱动表**)

```sql
create table a(f1 INT, f2 INT,INDEX(f1))ENGINE=INNODB;

create table b(f1 INT, f2 INT)ENGINE=INNODB;

insert into a values (1,1)(2,2)(3,3)(4,4)(5,5),(6,6);

insert into b values (3,3)(4,4)(5,5),(6,6)(7,7),(8,8);

select * from b;

//测试1
EXPLAIN select * from a left join on(a.f1 = b.f1) where (a.f2 = b.f2);

//测试2
EXPLAIN select * from a left join on (a.f1 = b.f1) and (a.f2 = b.f2);
```

##### **2、Simple Nested-Loop Join(简单嵌套循环连接)**

算法相当简单，从表A中取出一条数据1，遍历表B，将匹配到的数据放到result....以此类推，驱动表A中的每条记录与被驱动表B的记录进行判断：

==（每次从驱动表A拿出一条数据去遍历被驱动表所有记录）==

![image-20220125220008270](https://gitee.com/huangwei0123/image/raw/master/img/image-20220125220008270.png)

可以看出这种效率是非常底下的，以上述表A数据100条，表B数据1000条计算（==以上条数是where条件过滤后的数据条数==），则A*B = 10w次，开销统计如下：

==表小的做驱动表，表大的做被驱动表，这就是小表驱动大表的由来。==

| 开销统计（A=100,B=1000） | SNLJ  |
| ------------------------ | ----- |
| 外表扫描次数（小表A）    | 1     |
| 内表扫描次数（大表B）    | A     |
| 读取记录数               | B*A+A |
| join比较次数             | B*A   |
| 回表读取记录次数         | 0     |

当然Mysql肯定不会这么粗暴的去进行表的连接，所以就出现了后面的两种对Nested-Loop Join 优化算法。

##### **3、Index Nested-Loop Join(索引嵌套循环连接)**

Index Nested-Loop Join其优化的思路主要是为了`减少内层表数据的匹配次数`，所以要求被驱动表上必须`有索引`才行。==通过外层表匹配条件直接与内层表索引进行匹配，避免和内层表的每条记录去进行比较，这样极大的减少了对内层表的匹配次数==。

![image-20220125231609446](https://gitee.com/huangwei0123/image/raw/master/img/image-20220125231609446.png)

==驱动表中的每条记录通过被驱动表的索引进行访问，因为索引查询的成本是比较固定的==，**故mysql优化器都倾向于使用记录数少的表作为驱动表。**

| 开销统计         | SNLJ  | INLJ                  |
| ---------------- | ----- | --------------------- |
| 外表扫描次数     | 1     | 1                     |
| 内表扫描次数     | A     | 0                     |
| 读取记录数       | A+B*A | A+B(match)            |
| join比较次数     | B*A   | A*Index(Height)       |
| 回表读取记录次数 | 0     | B(match)(if possible) |

如果被驱动表加索引，效率是非常高的，但如果索引不是主键索引，所以还要进行一次回表查询。相比，被驱动表索引是主键，效率会更高。

##### **4、Block Nested-Loop Join（块嵌套循环连接）**

如果存在索引，那么会使用index的方式进行join，如果join的列没有索引，被驱动表要扫描的次数太多了。每次访问被驱动表，其表中的记录都会被加载到内存中，然后再从驱动表中取一条与其匹配，匹配结束后清除内存，然后再从驱动表中加载一条记录，然后把驱动表的记录再加载到内存匹配，这样周而复始，大大增加了IO的次数。为了减少被驱动表的IO次数，就出现了Block Nested-Loop Join的方式。

不再是逐条获取驱动表的数据，而是一块一块的获取，引入了`join buffer 缓冲区`，将驱动表join相关的部分数据列（大小受join buffer的限制）缓存到join buffer中，然后全表扫描驱动表，**被驱动表的每一条记录一次性和join buffer中的所有驱动表记录进行匹配（内存中操作）**，**将简单嵌套循环中的多次比较合并成一次，降低了被驱动表的访问频率。**

> 注意：
>
> 这里缓存的不只是关联的列，select 后面的列也会缓存起来。
>
> 在一个有N个join关联的sql中会分配 n-1个join buffer。所以查询的时候尽量减少不必要的字段，可以让join buffer中可以存放更多的列。

![image-20220125234147041](https://gitee.com/huangwei0123/image/raw/master/img/image-20220125234147041.png)

| 开销统计         | SNLJ  | INLJ                  | BNLJ                                             |
| ---------------- | ----- | --------------------- | ------------------------------------------------ |
| 外表扫描次数     | 1     | 1                     | 1                                                |
| 内表扫描次数     | A     | 0                     | A * user_column_size/ join_buffer_size +1        |
| 读取记录数       | A+B*A | A+B(match)            | A+B * （A * userd_column_size/join_buffer_size） |
| join比较次数     | B*A   | A*Index(Height)       | B*A                                              |
| 回表读取记录次数 | 0     | B(match)(if possible) | 0                                                |

参数设置

- block_nested_loop

通过`show variable like '%optimizer_switch'`查看`block_nested_loop`状态。默认是开启的。

- join_buffer_size 

驱动表能不能一次加载完，要看join buffer 能不能存储所有的数据，默认情况下`join_buffer_size = 256k`

##### 5、join小结

1、整体效率：INLJ > BNLJ > SNLJ

2、永远用小结果集驱动大结果集（本质就是减少外层循环的数据数量）（小的度量单位指的是 表行数 * 每行大小）

3、为被驱动表匹配的条件增加索引（减少内层表的循环匹配次数）

4、增大join buffer size 的大小（一次缓存的数据越多，那么内层扫描的次数就越少）

5、减少驱动表不必要的查询字段（字段越少，join buffer 所缓存的数据就越多）

6、Hash Join

从Mysql8.0.20版本引入，废弃了BNLJ

- Hash Join 是做 `大量数据集`连接时的常用方式，  优化器使用两个表中较小的表利用Join Key在内存中建立`散列表`，然后扫描较大的表并探测散列表，找出与Hash表匹配的行。
  - 这种方式适用于较小的表完全可以存放于内存中的情况，这样总成本就是访问两个表的成本之和
  - 在表很大的情况下并不能完全放入内存，这时优化器会将它分割成`若干不同的分区`，不能放入内存的部分就该分区写入磁盘的临时段，此时要求有较大的临时表而尽量提高IO的性能
  - 它能很好的工作于没有索引的大表和并行查询的环境中，并提供最好的性能。大多数人都说它时Join的重型升降机，Hash Join只能应用于等值连接（如Where A.code1 = B.code2），这是由于Hash的特点所决定的。

![image-20220126001325147](https://gitee.com/huangwei0123/image/raw/master/img/image-20220126001325147.png)

#### 3.5 小结

- 保证被驱动表的JOIN字段已经创建了索引
- 需要JOIN 的字段，数据类型保持绝对一致
- LEFT JOIN 时，选择`小表作为驱动表`， `大表作为被驱动表` 。**减少外层循环的次数**
- INNER JOIN 时，MySQL会自动将 `小结果集的表选为驱动表` 。选择相信MySQL优化策略
- 能够直接多表关联的尽量直接关联，不用子查询。(减少查询的趟数)
- 不建议使用子查询，建议将子查询SQL拆开结合程序多次查询，或使用 JOIN 来代替子查询
- 衍生表建不了索引

## 4、子查询优化

MySQL从4.1版本开始支持子查询，使用子查询可以进行SELECT语句的嵌套查询，**即一个SELECT查询的结果作为另一个SELECT语句的条件**。 `子查询可以一次性完成很多逻辑上需要多个步骤才能完成的SQL操作` 。

子查询的效率不高。原因：

1、执行子查询时MySQL需要为内层查询语句的查询结果 `建立一个临时表`,然后外层查询语句从临时表中查询记录。查询完毕后，再 `撤销这些临时表` 。**这样会消耗过多的CPU和IO资源，产生大量的慢查询**

2、子查询的结果集存储的临时表，不论是内存临时表还是磁盘临时表都` 不会存在索引` ，所以查询性能会受到一定的影响

3、对于返回结果集比较大的子查询，其对查询性能的影响也就越大

**在MySQL中，可以使用连接（JOIN）查询来替代子查询**。连接查询 `不需要建立临时表` ，其 `速度比子查询要快 `，如果查询中使用索引的话，性能就会更好

> 结论：尽量不要用NOT IN 或者 NOT EXISTS，用Left join xxx ON xxx where xx IS NULL 代替



## 5、排序优化

#### 5.1 排序优化

**问题：**在 WHERE 条件字段上加索引，但是为什么在 ORDER BY 字段上还要加索引呢？

**回答：**

在Mysql中，支持两种排序方式，分别是`FileSort`和`Index`排序

- index排序中，索引可以保证数据的有序性，不需要再进行排序，效率更高。
- FileSort排序则一般在`内存中`进行排序，占用CPU较多。如果待排结果较大，**会产生临时文件I/O到磁盘进行排序的情况，效率很低。**

优化建议：

1、SQL 中，可以在 WHERE 子句和 ORDER BY 子句中使用索引

**目的是在 WHERE 子句中`避免全表扫描`。**

**在 ORDER BY 子句 `避免使用 FileSort 排序` 。**

当然，某些情况下全表扫描，或者 FileSort 排序不一定比索引慢。但总的来说，我们还是要避免，以**提高查询效率**

2、尽量使用 Index 完成 ORDER BY 排序。如果 WHERE 和 ORDER BY 后面是相同的列就使用单索引列；如果不同就使用联合索引

3、无法使用 Index 时，需要对 FileSort 方式进行调优