# 查询优化以及索引优化

## 1、数据准备

学员表 插 50万 条， 班级表 插 1万 条

**步骤1：建表**

```sql
CREATE TABLE `class` (
  `id` INT (11) NOT NULL AUTO_INCREMENT,
  `className` VARCHAR (30) DEFAULT NULL,
  `address` VARCHAR (40) DEFAULT NULL,
  `monitor` INT NULL,
  PRIMARY KEY (`id`)
) ENGINE = INNODB AUTO_INCREMENT = 1 DEFAULT CHARSET = utf8;

CREATE TABLE `student` (`id` INT (11) NOT NULL AUTO_INCREMENT,
`stuno` INT NOT NULL,
`name` VARCHAR (20) DEFAULT NULL,
`age` INT (3) DEFAULT NULL,
`classId` INT (11) DEFAULT NULL,
PRIMARY KEY (`id`) #CONSTRAINT `fk_class_id` FOREIGN KEY (`classId`) REFERENCES `t_class` (`id`) 
) ENGINE=INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;
```

**步骤2：设置参数**

- 命令开启：允许创建函数设置：

```sql
# 不加global只是当前窗口有效。
set global log_bin_trust_function_creators=1; 
```

**步骤3：创建函数**

```sql
#随机产生字符串 
DELIMITER //

CREATE FUNCTION rand_string (n INT) RETURNS VARCHAR (255)
BEGIN
  DECLARE chars_str VARCHAR (100) DEFAULT 'abcdefghijklmnopqrstuvwxyzABCDEFJHIJKLMNOPQRSTUVWXYZ';
  DECLARE return_str VARCHAR (255) DEFAULT '';
  DECLARE i INT DEFAULT 0;
  WHILE
    i < n DO SET return_str = CONCAT (
      return_str,
      SUBSTRING (chars_str, FLOOR (1+ RAND () * 52), 1)
    );
    SET i = i + 1;
  END WHILE;
  RETURN return_str;
END //

DELIMITER;

#假如要删除
# drop function rand_string;
```

随机产生班级编号

```sql
#用于随机产生多少到多少的编号 
DELIMITER //

CREATE FUNCTION rand_num (from_num INT, to_num INT) RETURNS INT (11)
BEGIN
  DECLARE i INT DEFAULT 0;
  SET i = FLOOR (
    from_num + RAND () * (to_num - from_num + 1)
  );
  RETURN i;
END //

DELIMITER;
#假如要删除
# drop function rand_string;
```

**步骤4：创建存储过程**

```sql
#创建往stu表中插入数据的存储过程
DELIMITER //

CREATE PROCEDURE insert_stu (START INT, max_num INT)
BEGIN
  DECLARE i INT DEFAULT 0;
  SET autocommit = 0;
  REPEAT
    SET i = i + 1;
    INSERT INTO student (stuno, NAME, age, classId)
    VALUES
      (
        (START + i),
        rand_string (6),
        rand_num (1, 50),
        rand_num (1, 1000)
      );
    UNTIL i = max_num
  END REPEAT;
  COMMIT;
END //

DELIMITER;
#drop PROCEDURE insert_stu;
```

创建往class表中插入数据的存储过程

```sql
#执行存储过程，往class表添加随机数据 
 DELIMITER //

CREATE PROCEDURE `insert_class` (max_num INT)
BEGIN
  DECLARE i INT DEFAULT 0;
  SET autocommit = 0;
  REPEAT
    SET i = i + 1;
    INSERT INTO class (classname, address, monitor)
    VALUES
      (
        rand_string (8),
        rand_string (10),
        rand_num (1, 100000)
      );
    UNTIL i = max_num
  END REPEAT;
  COMMIT;
END //

DELIMITER;
#drop PROCEDURE insert_stu;
```

**步骤5：调用存储过程**

class

```sql
#执行存储过程，往class表添加1万条数据 
CALL insert_class(10000);
```

stu

```sql
#执行存储过程，往stu表添加50万条数据 
CALL insert_stu(100000,500000);
```

**步骤6：删除某表上的索引**

创建存储过程

```sql
DELIMITER //

CREATE PROCEDURE `proc_drop_index` (
  dbname VARCHAR (200),
  tablename VARCHAR (200)
)
BEGIN
  DECLARE done INT DEFAULT 0;
  DECLARE ct INT DEFAULT 0;
  DECLARE _index VARCHAR (200) DEFAULT '';
  DECLARE _cur CURSOR FOR
  SELECT
    index_name
  FROM
    information_schema.STATISTICS
  WHERE table_schema = dbname
    AND table_name = tablename
    AND seq_in_index = 1
    AND index_name <> 'PRIMARY';
  #每个游标必须使用不同的declare continue handler for not found set done=1来控制游标的结束 
   DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = 2;
  #若没有数据返回,程序继续,并将变量done设为2 
   OPEN _cur;
  FETCH _cur INTO _index;
  WHILE
    _index <> '' DO SET @str = CONCAT (
      "drop index ",
      _index,
      " on ",
      tablename
    );
    PREPARE sql_str FROM @str;
    EXECUTE sql_str;
    DEALLOCATE PREPARE sql_str;
    SET _index = '';
    FETCH _cur INTO _index;
  END WHILE;
  CLOSE _cur;
END //

DELIMITER;

# 执行存储过程
CALL proc_drop_index("dbname","tablename");
```

## 2、索引失效案例

#### 2.1 全值匹配我最爱

==where子句中出现的所有字段，都会去匹配索引。找到使用索引的最优解。==

系统中经常出现的sql语句如下：

```sql
EXPLAIN select sql_no_cache * from student where age = 30;
EXPLAIN select sql_no_cache * from student where age = 30 and classId = 4;
EXPLAIN select sql_no_cache * from student where age = 30 and classId = 4 and name = 'abcd';
```

建立索引前执行：（关注时间）

```mysql
mysql> EXPLAIN select sql_no_cache * from student where age = 30 and classId = 4 and name = 'abcd';
Empty set , 1 warning(0.28 sec) 
```

建立索引

```sql
create index idx_age on student(age);

create index idx_age_classId on student(age,classId);

create index idx_age_classId_name on student(age,classId,name);
```

可以看到，创建索引前查询时间是0.28秒，创建索引后的查询时间是0.01s,有效利用索引，可以帮我们极大的提升查询效率。



#### 2.2 最左前缀法则

在MySQL建立联合索引时，会遵守最佳左前缀匹配原则，即最左优先匹配原则，在检索数据时，从联合索引的最左边开始匹配。

eg1：

```sql
EXPLAIN select sql_no_cache * from student where student.age=30 and student.name = 'abcd';
```

eg2：

```sql
EXPLAIN select sql_no_cache * from student where student.classId=1 and student.name = 'abcd';
```

eg3：索引idx_age_classId_name还能正常使用？

```sql
EXPLAIN select sql_no_cache * from student where classId = 4 and  student.age=30 and student.name = 'abcd';
```

==如果索引了多列，就要遵守最左前缀原则，指的是查询从索引的最左列开始并且不跳过索引中的列。==

```sql
EXPLAIN select sql_no_cache * from student where student.age=30 and student.name = 'abcd';
```

![image-20220125124556343](https://gitee.com/huangwei0123/image/raw/master/img/image-20220125124556343.png)

虽然可以被正常使用，但是只有部分被使用到了。

```sql
EXPLAIN select sql_no_cache * from student where classId=1 and name = 'abcd';
```

![image-20220125124705242](https://gitee.com/huangwei0123/image/raw/master/img/image-20220125124705242.png)

因为缺少了联合索引的最左列，所以没有使用上索引。

结论：Mysql可以为多个字段创建索引，一个索引包括16个字段。==对于联合索引，过滤条件要使用索引必须按照索引建立时的顺序，依次满足，一旦跳过某个字段，索引后的字段都无法被使用。如果查询的条件中没有使用到这些字段中的第一个字段时，联合索引将不会被使用。==

> 扩展：Alibaba 《java开发手册》
>
> 索引文件具有B-tree的最左前缀匹配特性，如果左边的值未确定，那么无法使用此索引

#### 2.3 主键插入顺序

对于一个使用innoDB存储引擎的表来说，在我们没有显示的创建索引时，表中的数据实际上都是存储在`聚簇索引`的叶子节点上的。

而记录又是存储在数据页中的，数据页和记录又是按照记录`主键值从小到大`的顺序进行排序，所以如果我们`插入`的记录的==主键值是依次增大==的话，那么我们每插满一个数据页就换到下一个数据页继续插，而==如果我们插入的主键值忽大忽小的话，就可能出现页分裂的情况==。

![image-20220125134858726](https://gitee.com/huangwei0123/image/raw/master/img/image-20220125134858726.png)

如果此时再插入一条数据为9的记录，那它插入的位置就如下图所示

![image-20220125135016802](https://gitee.com/huangwei0123/image/raw/master/img/image-20220125135016802.png)

可能这个数据页已经满了，再插进来怎么办呢？**我们需要把当前页面分裂成两个页面，把本页中的一些记录移动到新创建的这个页中。页面分裂和记录移位意味着什么？**

==就意味着：**性能消耗**！==

==所以我们想尽量避免这样无谓的性能损耗，最好让插入的记录**主键值依次递增**，这样就不会发生这样的性能损耗了。==所以我们建议，让主键具有auto_increment，让存储引擎自己为表生成主键，而不是我们手动插入，比如`person_info`表

```sql
CREATE TABLE person_info (
  id INT UNSIGNED NOT NULL AUTO_INCREMENT,
  NAME VARCHAR (100) NOT NULL,
  birthday DATE NOT NULL,
  phone_number CHAR (11) NOT NULL,
  country VARCHAR (100) NOT NULL,
  PRIMARY KEY (id),
  KEY idx_name_birthday_phone_number (NAME (10), birthday, phone_number)
);
```

我们自定义的**主键列 id 拥有 AUTO_INCREMENT 属性**，==在插入记录时存储引擎会自动为我们填入自增的主键值。这样的主键占用空间小，顺序写入，减少页分裂。==

#### 2.4 计算、函数、类型转换（自动|手动）导致索引失效

1、这两种sql哪种写法更好

```sql
EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE student.name LIKE 'abc%';

EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE LEFT(student.name,3) = 'abc';
```

2、创建索引

```sql
CREATE INDEX idx_name ON student(NAME);
```

第一种：索引优化生效

```sql
EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE student.name LIKE 'abc%';
```

![image-20220125144723745](https://gitee.com/huangwei0123/image/raw/master/img/image-20220125144723745.png)

第二种：索引失效

```sql
EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE LEFT(student.name,3) = 'abc';
```

![image-20220125144831515](https://gitee.com/huangwei0123/image/raw/master/img/image-20220125144831515.png)

==索引列上不能使用函数==

再举例：

student表的字段stuno上设置有索引

```sql
CREATE INDEX idx_sno ON student(stuno);
```

```sql
EXPLAIN SELECT SQL_NO_CACHE id, stuno, NAME FROM student WHERE stuno+1 = 900001;
```

![image-20220125145128948](https://gitee.com/huangwei0123/image/raw/master/img/image-20220125145128948.png)

索引优化生效：

```sql
EXPLAIN SELECT SQL_NO_CACHE id, stuno, NAME FROM student WHERE stuno = 900000;
```

==索引列上不能有计算==

再举例：

student表的字段name上设置有索引

```sql
CREATE INDEX idx_name ON student(NAME);
```

```sql
EXPLAIN SELECT id, stuno, name FROM student WHERE SUBSTRING(name, 1,3)='abc';
```

![image-20220125145400300](https://gitee.com/huangwei0123/image/raw/master/img/image-20220125145400300.png)

```sql
EXPLAIN SELECT id, stuno, NAME FROM student WHERE NAME LIKE 'abc%';
```

![image-20220125145416196](https://gitee.com/huangwei0123/image/raw/master/img/image-20220125145416196.png)

#### 2.5 类型转型导致索引失效

下列哪个sql可以使用到索引（假设name字段上设置有索引）

```sql
# 未使用到索引
EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE name=123;
```

![image-20220125145743727](https://gitee.com/huangwei0123/image/raw/master/img/image-20220125145743727.png)

```sql
# 使用到索引 
EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE name='123';
```

![image-20220125145807357](https://gitee.com/huangwei0123/image/raw/master/img/image-20220125145807357.png)

==name=123发生类型转换，索引失效。==

#### 2.6 范围条件右边的列索引失效

```sql
ALTER TABLE student DROP INDEX idx_name; 

ALTER TABLE student DROP INDEX idx_age;

ALTER TABLE student DROP INDEX idx_age_classid;

EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE student.age=30 AND student.classId>20 AND student.name = 'abc' ;
```

![image-20220125152609268](https://gitee.com/huangwei0123/image/raw/master/img/image-20220125152609268.png)

那么索引，idx_age_classId_name，这个索引还能正常使用么?

- 不能，范围右边的列不能使用 比如 ==(<)，（<=）,（>），(>=)和between等范围条件==
- **如果出现这种SQL，应该建立,将使用范围查找的字段放到最后**

```sql
create index idx_age_name_classid on student(age,name,classid);
```

将范围查询条件放置语句最后：

```sql
EXPLAIN SELECT SQL_NO_CACHE * FROM student WHERE student.age=30 AND student.name = 'abc' AND student.classId>20 ;
```

![image-20220125152644724](https://gitee.com/huangwei0123/image/raw/master/img/image-20220125152644724.png)

> 应用开发中范围查询，例如，金额查询，日期查询往往都是范围查询。应该将查询条件防止where语句最后
>
> （创建的联合索引中，务必把范围涉及到的字段写在最后）



#### 2.7 不等于（!= | <> ）索引失效

- 为name字段创建索引

```sql
create index idx_name on student(name);
```

- 查看索引是否失效

```sql
explain select sql_no_cache * from student where name <> 'abc'
```

![image-20220125154324177](https://gitee.com/huangwei0123/image/raw/master/img/image-20220125154324177.png)

或者

```sql
explain select sql_no_cache * from student where name != 'abc'
```

**场景举例：用户踢出需求，将财务数据，产品利润金额不等于0的都统计出来。**

#### 2.8 is null 可以使用索引，is not null 无法使用索引

- is null：可以触发索引

```sql
explain select sql_no_cache * from student where age is null;
```

![image-20220125154650575](https://gitee.com/huangwei0123/image/raw/master/img/image-20220125154650575.png)

- is not null ：不能触发索引

```sql
explain select sql_no_cache * from student where age is not null;
```

![image-20220125154716684](https://gitee.com/huangwei0123/image/raw/master/img/image-20220125154716684.png)

==结论：最好在设计表的时候就将字段设置为 not null 约束==

比如你可以将int类型的字段，默认值设置为0，将字符类型的默认值设置为空字符串（''）

==扩展：同理，在查询中使用not like 也无法使用索引，导致全表扫描==

#### 2.9 like以通配符%开头索引失效

在使用like关键字的查询语句中，如果匹配字符串的第一个字符为"%"，索引就不会起作用，只有"%"不在第一个位置，索引才会起作用。

- 使用到索引

```sql
explain select sql_no_cache * from student where name like 'ab%';
```

![image-20220125155254433](https://gitee.com/huangwei0123/image/raw/master/img/image-20220125155254433.png)

- 未使用到索引

```sql
explain select sql_no_cache * from student where name like '%ab%';
```

![image-20220125155324462](https://gitee.com/huangwei0123/image/raw/master/img/image-20220125155324462.png)

> 扩展：Alibaba《Java手册》
>
> 【强制】页面搜索严禁左模糊或者全模糊，如果需要请走搜索引擎模块解决（一般互联网都使用ES，原理是倒排索引）

#### 2.10 OR前后存在非索引的列，索引失效

在Where子句中，如果在OR 前的条件列进行了索引，而在OR后的条件列没有进行索引，那么索引也会失效。==也就是说，OR前后的两个条件中的列都是索引时，查询中才会使用索引。==

 因为OR的含义就是两个只要满足一个条件即可，**因此只有一个条件列进行了索引是没有意义的，只要有条件列没有进行索引，就会进行全表扫描，因此索引列也会失效。**

查询语句使用OR关键字的情况

```sql
# 未使用到索引
explain select sql_no_cache * from student where age = 10 OR classid = 100;
```

![image-20220125162629935](https://gitee.com/huangwei0123/image/raw/master/img/image-20220125162629935.png)

**因为calssid字段没有索引，所以导致上述查询语句没有使用到索引。**

```sql
# 使用到索引
explain select sql_no_cache * from student where age = 10 OR name = 'Abel';
```

![image-20220125162933450](https://gitee.com/huangwei0123/image/raw/master/img/image-20220125162933450.png)

因为age字段和name字段上都有索引，所以查询中使用了索引，你能看道这里使用了`index_merge`，简单来说index_merge，就是对age和name属性分部进行了扫描，然后将这两个结果集进行了合并。这样做的好处就是`避免了全表扫描`。



#### 2.11 数据库和表的字符集统一使用utf8mb4

统一使用uft8bm4(5.5版本以上才支持)兼容性更好，统一字符集可以避免由于字符集转换产生的乱码。不同的字符集进行比较前需要进行转换，导致索引失效。



#### 2.12 总结

一般性建议：

- 对于单列索引，尽量选择针对当前query过滤性更好的字段进行索引
- 在选择组合索引的时候，当前query中过滤性最好的字段在索引字段顺序中，位置越靠前越好。
- 在选择组合索引的时候，尽量选择能够包含当前query中的where子句中更多字段的索引。（区分度越高）
- 在选择组合索引的时候，如果某个字段可能出现范围查询时，尽量把这个字段放在索引次序的最后面。

==**总之，写SQL时，尽量避免造成索引失效的情况。**==

## 3、关联查询优化

#### 3.1 数据准备

![image-20220125172119233](https://gitee.com/huangwei0123/image/raw/master/img/image-20220125172119233.png)

#### 3.2 采用左外连接

下面开始EXPLAIN分析

```sql
EXPLAIN select sql_no_cache * from type left join book on type.card = book.card;

#在外连接中，左边的表 叫驱动表，右边的表叫做被驱动表
```

![image-20220125173906263](https://gitee.com/huangwei0123/image/raw/master/img/image-20220125173906263.png)

添加索引

```sql
create index idx_book_card on book(card); 

create index idx_type_card on book(card); 

# 如果类型不一致，可以去掉其中一个表得索引。
```

左连接特性决定： 

==**left join条件用于确定如何从右表搜索行，左边一定都有，所以`右边是我们的关键点，一定需要建立索引`**==

![image-20220125173918533](https://gitee.com/huangwei0123/image/raw/master/img/image-20220125173918533.png)

#### 3.3 采用内连接

换成inner join（Mysql会自动选择驱动表）

```sql
explain select sql_no_cache * from type inner join book on type.card = book.card;
```

![image-20220125174423122](https://gitee.com/huangwei0123/image/raw/master/img/image-20220125174423122.png)

添加索引优化

```sql
create index idx_book_card on book(card); 

create index idx_type_card on book(card); 
```

![image-20220125174911277](https://gitee.com/huangwei0123/image/raw/master/img/image-20220125174911277.png)

**结论：**

- 对于内连接来说，查询优化器是可以决定谁作为驱动表，谁作为被驱动表出现的。

- 对于内连接来说，连接条件中只有一个字段有索引，则有索引的字段所在的表会被作为被驱动表。

- ==对于内连接来说，在两个表的连接条件都存在索引的情况下，会选择小表作为驱动表。对应一个优化原则（小表驱动大表）==，小表就是扫描查询成本比较低的表



#### 3.4 join语句原理

#### 3.5 小结