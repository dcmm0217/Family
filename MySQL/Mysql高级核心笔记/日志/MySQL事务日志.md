# MySQL事务日志

事务有4种特性：原子性、一致性、隔离性和持久性。那么事务的四种特性到底是基于什么机制实现呢？

- 事务的**隔离性**由`锁机制`实现
- 而**事务的原子性、一致性和持久性**由事务的**redo日志**和**undo日志**来保证
  - redo log 称为 `重做日志`，提供再写入操作，恢复提交事务修改的页操作，用来保证事务的持久性。
  - undo log 称为 `回滚日志`，回滚行记录到某个特定版本，用来保证事务的原子性、一致性。

有的DBA或许会认为undo是redo的逆过程，其实不然。redo和undo都可以视为是一种`恢复操作`，但是：

- redo log ：是存储引擎层（innodb）生成的日志，记录的是`物理级别`上的页修改操作，比如页号xxx，偏移量yyy，写了zzz数据，主要为了保证数据的可靠性。
- undo log：是存储引擎（innodb）生成的日志，记录的是`逻辑操作`的日志。比如对某一行数据进行了insert语句操作，那么undo log就记录一条与之相反的delete操作。主要用于`事务的回滚`（undo log 记录的是每个修改操作的**逆日志**）和**一致性非锁定读**（==undo log回滚行记录到某种特定版本--MVCC==，即多版本并发控制）

## 1、redo日志

#### 1.1 为什么需要redo日志

一方面，缓冲池可以帮助我们消除cpu和磁盘间的鸿沟，checkpoint机制可以保证数据的最终落盘，然而由于checkpoint`并不是每次变更的时候就会触发`的，而是master线程隔一段时间就去处理的。==所以最坏的情况就是事务提交后，刚写完缓冲池，数据库宕机了，那么这段数据就是丢失的，无法恢复==。

另一方面，==事务包含`持久性`的特性，就是说对于一个已经提交的事务，在事务提交后即使系统发生了崩溃，这个事务对数据库种所做的更改也不能丢失==。

那么如何保证这个持久性呢？

一个`简单的做法`：**在事务提交完成之前，该事务所修改的所有页面都刷新到磁盘**，但是这个简单粗暴的做法有些问题。

`另一个解决思路：` 我们只是想让已经提交了的事务对数据库中数据所做的修改永远生效，即使后来系统崩溃，在重启后也能把这种修改恢复出来。**所以我们其实没有必要记录在每次事务提交时，就把该事务在内存中修改过的==全部页==刷新到磁盘。**只需要把`修改`了哪些东西`记录一下`就好。

例如：某个事务将系统表空间中`第10号`页面中偏移量为`100处`的那个字节的值`1`改成`2`。

我们只需要记录一下：将0号表空间的10号页面的偏移量为100处的值更新为2。

![image-20220129230321191](https://gitee.com/huangwei0123/image/raw/master/img/image-20220129230321191.png)

