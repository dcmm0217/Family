## 记一次工作中慢查询的优化

#### 1、角色和资源关系表

```sql
CREATE TABLE `role_resource` (
  `ROLE_ID` varchar(32) COLLATE utf8_bin NOT NULL COMMENT '资源id',
  `RESOURCE_ID` varchar(32) COLLATE utf8_bin NOT NULL COMMENT '角色id',
  `TENANT_ID` varchar(32) COLLATE utf8_bin NOT NULL COMMENT '租户id',
  PRIMARY KEY (`ROLE_ID`,`RESOURCE_ID`,`TENANT_ID`) USING BTREE,
  KEY `TENANT_ID` (`TENANT_ID`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COLLATE=utf8_bin ROW_FORMAT=DYNAMIC COMMENT='角色和资源关系表'
```

慢SQL日志

```sql
# Time: 2021-11-12T03:10:00.697067Z
# User@Host: ycp_kf[ycp_kf] @  [192.168.0.176]  Id: 5223459
# Query_time: 2.319295  Lock_time: 0.000000 Rows_sent: 3  Rows_examined: 59094
use bt_system;
SET timestamp=1636686600;
SELECT role_id AS roleId, resource_id AS resourceId, tenant_id AS tenantId FROM ROLE_RESOURCE WHERE tenant_id = '83060345edf246298eb6899ade8d29ff' AND resource_id IN ('fabb24743e4f45499da45e6e01bbe678');
```

Explain分析SQL

![image-20211209102144058](https://gitee.com/huangwei0123/image/raw/master/img/image-20211209102144058.png)

1、type 为 index  全索引扫描 

2、possbile_keys 表示没有可用的索引选择

3、发现 key 为使用了 主键索引，是因为建表的时候 创建了一个联合主键索引` PRIMARY KEY (`ROLE_ID`,`RESOURCE_ID`,`TENANT_ID`) USING BTREE,`但是使用索引又不符合最左前缀原则，相当于没用

4、rows 扫描行数为60924行，太多耗时。因为是全索引扫描

根据实际情况分析，tenant_id 这列我们其实项目中使用不到，一直会是默认值，我们就不对其进行修改，在resource_id上新增一个普通索引

```sql
alter tbale role_resource add index idx_RESOURCE_ID(RESOURCE_ID);
```

添加索引后，再使用explain分析如图

![image-20211209111055258](https://gitee.com/huangwei0123/image/raw/master/img/image-20211209111055258.png)

确认使用了索引`idx_RESOURCE_ID`，查询时间由原来2s，变为0.01s



