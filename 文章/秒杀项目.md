# 秒杀项目



## 1、分布式会话是怎么实现的，为什么要用分布式会话？

#### 1、为什么？

因为我们项目使用了2台应用服务器做了负载均衡和反向代理。如果还是单机版Session的情况，会出现

**在A1系统登录后创建并保存Session，再次发起请求，请求被转发到A2系统上显示未登录的情况**

**所以我们需要把生产的SessionId存到Redis中**

#### 2、实现步骤：

首先我们引入两个Jar包

```xml
<!--redis-->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-redis</artifactId>
    <version>2.3.1.RELEASE</version>
</dependency>
<!--将session 放入redis-->
<dependency>
    <groupId>org.springframework.session</groupId>
    <artifactId>spring-session-data-redis</artifactId>
    <version>2.0.5.RELEASE</version>
</dependency>
```

并且新建一个`RedisConfig`类，暂时不进行任何操作只添加两个注解

```java
@Component
@EnableRedisHttpSession(maxInactiveIntervalInSeconds = 3600)
```

并在properties中添加redis相关配置

```properties
# redis配置
spring.redis.host=（对应服务器主机ip）
spring.redis.port=6379
spring.redis.database=10

# 设置jedis 连接池
spring.redis.jedis.pool.max-active=50
spring.redis.jedis.pool.min-idle=20
```

由于登录时我们将`UserModel`存在session中，现在存储在`redis`中，我们要给`UserModel`**配置序列化操作**。

```
为什么存储到Redis要将实体类进行序列化？
1、任何存储都需要序列化。
2、只不过常规你在用DB一类存储的时候，这个事情DB帮你在内部搞定了（直接把SQL带有类型的数据转换成内部序列化的格式，存储；读取时再解析出来）。
3、redis又不是java专用的，它不支持java特有的数据类型。Redis并不会帮你做这个事情。当你用Redis的key和value时，value对于redis来讲就是个byte array。
```

**登录时，我们生产Token，将其代表`sessionId`与`UserModel`以键值对的形式存入`Redis`中**

```java
String uuidToken = UUID.randomUUID().toString().replaceAll("-","");
// 建立token和用户登录态之间的联系
redisTemplate.opsForValue().set(uuidToken,userModel,1, TimeUnit.HOURS);

// 返回给前端
return CommonReturnType.create(uuidToken);
```

```javascript
// 如果登录成功，则将后端返回的token存放到localStorage里面。
if (data.status == "success") {
    alter("登录成功");
    var token = data.data;
    window.localStorage["token"] = token;
    window.location.href = "listitem.html";
}
```

前端要下单时

```javascript
$("#createorder").on("click", function () {
    var token = window.localStorage["token"];
    if (token == null) {
        alert("没有登录不能下单");
        window.location.href = "login.html";
        return false;
    }
    $("#verifyDiv img").attr("src","http://" + g_host + "/order/generateVerifyCode?token="+token);
    $("#verifyDiv").show();
});
```

后端下单校验用户是否登录

```java
String token = request.getParameterMap().get("token")[0];

if (StringUtils.isEmpty(token)) {
    throw new BusinessException(EmBusinessError.USER_NOT_LOGIN, "用户还未登录,不能下单");
}
//从redis中拿到对应uuid的userModel
UserModel userModel = (UserModel) redisTemplate.opsForValue().get(token);
if (userModel == null) {
    throw new BusinessException(EmBusinessError.USER_NOT_LOGIN, "用户还未登录,不能下单");
}
```

分布式会话，有两种常见的实现方式：

1. 第一种是通过Spring提供的API，将Tomcat的`SessionId`和`UserModel`存到Redis服务器上。
2. 第二种是通过UUID生成登录`token`，将`token`和`UserModel`存到Redis服务器上。



## 2、看你项目上说用到了多级缓存？是怎么用的？为什么要用呢?

首先要明白使用缓存的目的，主要是**提高查询效率**。减少数据库的压力，提高系统的QPS

```
1、Redis缓存
2、热点内存本地缓存（JVM）
3、nginx proxy cache 缓存
4、nginx lua 缓存

```

#### 1、Redis缓存

- 单机版
- sentinal哨兵模式
- 集群cluster模式

我们采用单机版对查询进行缓存

item商品信息，会查询3张表，首先是item**基础信息表**，然后是**库存表**，再者是**promo活动表**（该商品是否参与秒杀活动），故很消耗Mysql的性能，我们采用缓存的方式如果其id相同，则返回相同的Model即可。

**我们采用item_id，表示Item商品+商品id 代表其key；**

Value即是我们的UserModel对象。

**当我们访问商品时，我们先从redis中获取，如果redis中没有，则访问数据库获取，并且写回到redis；**

```java
// ItemController代码
// 根据redis 获取商品 Model
ItemModel itemModel = (ItemModel) redisTemplate.opsForValue().get("item_" + id);
// 若不存在
if(itemModel == null){
    itemModel=itemService.getItemById(id);
    // 将其放入Redis
    redisTemplate.opsForValue().set("item_" + id,itemModel);
    redisTemplate.expire("ietm_"+id,10, TimeUnit.MINUTES);
}
```

然后此时我们查看redis中的数据时是乱码的形式，原因为我们没有配置其序列化格式，其采用自己的一种编码方式

```java
public class RedisAutoConfiguration {
    @Bean
    @ConditionalOnMissingBean(
        name = {"redisTemplate"}// 此注解代表 当我们spring容器中没有redistemplate Bean时，其自动给我们配置此编码格式的Bean
    )
    public RedisTemplate<Object, Object> redisTemplate(RedisConnectionFactory redisConnectionFactory) throws UnknownHostException {
        RedisTemplate<Object, Object> template = new RedisTemplate();
        template.setConnectionFactory(redisConnectionFactory);
        return template;
}
```

此时我们自己配置一个Bean并且解决Reids序列化的问题

```java
@Bean
public RedisTemplate redisTemplate(RedisConnectionFactory redisConnectionFactory){
    RedisTemplate redisTemplate = new RedisTemplate();
    redisTemplate.setConnectionFactory(redisConnectionFactory);

    //首先解决key的序列化格式
    StringRedisSerializer stringRedisSerializer = new StringRedisSerializer();
    redisTemplate.setKeySerializer(stringRedisSerializer);

    //解决value的序列化格式
    Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class);

    //解决日期的序列化格式
    ObjectMapper objectMapper = new ObjectMapper();
    SimpleModule simpleModule = new SimpleModule();
    simpleModule.addSerializer(DateTime.class, new JodaDateTimeJSONSerializer());
    simpleModule.addDeserializer(DateTime.class, new JodaDateTimeDeserializer());

    objectMapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);
    objectMapper.registerModule(simpleModule);

    jackson2JsonRedisSerializer.setObjectMapper(objectMapper);
    redisTemplate.setValueSerializer(jackson2JsonRedisSerializer);
    return redisTemplate;
}

// 对于日期而言，序列化后是一个很长的毫秒数。我们希望是yyyy-MM-dd HH:mm:ss的格式，还需要进一步处理。新建serializer包，里面新建两个类。
public class JodaDateTimeJSONSerializer extends JsonSerializer<DateTime> {
    @Override
    public void serialize(DateTime dateTime, JsonGenerator jsonGenerator, SerializerProvider serializerProvider) throws IOException {
        jsonGenerator.writeString(dateTime.toString("yyyy-MM-dd HH:mm:ss"));
    }
}
public class JodaDateTimeDeserializer extends JsonDeserializer<DateTime> {
    @Override
    public DateTime deserialize(JsonParser jsonParser, DeserializationContext deserializationContext) throws IOException, JsonProcessingException {
        String dateString = jsonParser.readValueAs(String.class);
        DateTimeFormatter formatter=DateTimeFormat.forPattern("yyyy-MM-dd HH:mm:ss");
        return DateTime.parse(dateString,formatter);
    }
}
```

#### 2、使用本地缓存优化

虽然Redis很好，但是还是涉及网络的IO，没有本地缓存快，我们在Redis之前添加一层**本地热点**，所谓本地，就是利用本地 JVM的内存，所谓热点，由于 JVM 内存有限，仅存放多次查询的数据（一般是一秒内上 千 甚至上万的访问）。

每个本地缓存也就是存储在各自服务器的，所以我们对脏数据也不是特别敏感，但是一定要有过期时间，并且要设置的比较短。

这里本地缓存我们可以使用`HashMap`,但是其不能支持并发修改，故我们可以选取`ConcurrentHashMap`但是无法高效处理**过期时限**、没有**淘汰机制**等问题，所以这里使用了`Google`的`Guava Cache`方案。**本质上也是一种可并发的hashmap**

```xml
// 配置Guava依赖
<dependency>
    <groupId>com.google.guava</groupId>
    <artifactId>guava</artifactId>
    <version>19.0</version>
</dependency>
```

封装本地缓存的Service接口

```java
//封装本地缓存操作类
public interface CacheService {
    //存方法
    void setCommonCache(String key,Object value);

    //取方法
    Object getFromCommonCache(String key);
}
```

其实现类

```java
@Service
public class CacheServiceImpl implements CacheService {

    private Cache<String,Object> commonCache = null;

    @PostConstruct
    //springbean会在对应bean加载的时候，优先执行对应的init方法
    public void init(){
        commonCache = CacheBuilder.newBuilder()
                //设置缓存容器的初始容量为10
                .initialCapacity(10)
                //设置缓存中最大的可以存放的key，超过100个会按照lru的策略移除缓存项
                .maximumSize(100)
                //设置写缓存后多少秒过期
                .expireAfterWrite(60, TimeUnit.SECONDS).build();
    }

    @Override
    public void setCommonCache(String key, Object value) {
        commonCache.put(key,value);
    }

    @Override
    public Object getFromCommonCache(String key) {
        return commonCache.getIfPresent(key);
    }
}
```

**在获取商品id详情时，先走本地缓存 --- Redis缓存 -- mysql服务器**

```java
//商品信息浏览
@GetMapping(value = "/get")
@ResponseBody
public CommonReturnType getItem(@RequestParam("id")Integer id){
    //多级缓存 优化访问策略   1、本地缓存  2、redis缓存 3、数据库
    ItemModel itemById = null;
    //先去本地缓存
    itemById = (ItemModel) cacheService.getFromCommonCache("item_"+id);
    if (itemById==null){
        //根据商品的id到redis内获取对应的UserModel
        itemById = (ItemModel) redisTemplate.opsForValue().get("item_" + id);
        //若redis内不存在对应的itemModel，则访问下游的service
        if (itemById==null){
            itemById = itemService.getItemById(id);
            //设置itemModel到redis内
            redisTemplate.opsForValue().set("item_"+id,itemById);
            //缓存一定要记得设置过期时间,不仅仅是为了redis的一个容量性能考虑，更为了业务的能力，
            //当我们的数据发生改变，就需要一个清理缓存的机制
            redisTemplate.expire("item_"+id,10, TimeUnit.MINUTES);
        }
        //设置本地缓存
        cacheService.setCommonCache("item_"+id,itemById);
    }
    ItemVO itemVO = convertVOFromModel(itemById);
    return CommonReturnType.create(itemVO);
}
```

至此**tps**能最高到达**4000**，并且保持在**50ms**以内，因为大部分重复的访问全部走向了**本地缓存**，对服务器没有一点压力

**本地缓存的缺点：**

1、更新特别麻烦，容易产生脏缓存

2、受到 JVM 容量限制

#### 3、Nginx Proxy Cache缓存

**启用nginx缓存的条件：**

- nginx可以用作反向代理
- 依靠文件系统存索引级的文件(将请求存成本地文件，在本地磁盘中)
- 依靠内存缓存文件地址（接下来有点绕：内存缓存文件的内容value是以文件形式存放在磁盘中，但是缓存的key以缓存的方式在内存中，缓存key在内存的内容就是 —内存缓存文件的地址）也就是说nginx proxy cahce 寻址的key在内存当中，value在磁盘中，key内存中存储的是value的地址
  

通过**Redis缓存**减少了**MySQL的重复查询**，通过**本地缓存**，减少了Redis的**网络I/O**，大大的提高了效率，但是客户端请求Nginx服务器也有分发过程，需要去请求后面的两台应用服务器，有一定网络I/O，我们可以直接把**热点数据**存放到**Nginx服务器**上。

通过`Nginx Proxy Cache`作为文件存放在指定目录下。

```shell
# 申明一个cache缓存节点 evels 表示以二级目录存放
    proxy_cache_path /usr/local/openresty/nginx/tmp_cache levels=1:2 keys_zone=tmp_cache:100m inactive=7d max_size=10g;
...
server{
    location / {
        #proxy_cache 目录
        proxy_cache tmp_cache;
        proxy_cache_key $uri;
        #只有后端返回以下状态码才缓存
        proxy_cache_valid 200 206 304 302 7d;
    }
}
```

sbin/nginx -s reload重启服务器

这样在tmp_cache/下生成了对应的文件为JSON格式。

但是不好用，它是放在本地磁盘上的，有磁盘I/O，而且一般企业级都是用到的NAS。 一般很少使用。

#### 4、nginx lua脚本

协程机制：

- 依附于线程的内存模型，切换开销小
- 遇阻塞及归还执行权，代码同步
- 无需加锁

后2种方式属于服务器的优化了。

## 3、看你项目里面使用了CDN？怎么用的？全页面静态化是怎么做的？

#### 1、什么是CDN?

CDN可以理解为一个无限大的内容磁盘缓存，本身没有文件存储。当用户访问getItem的一个静态资源文件的时候，会根据路由规则查看本地是否有这样的文件，如果有，直接返回，没有就**回源**到**源站**，回源到下面的OSS中获取静态资源文件。

CDN一边返回对应的文件，一边将文件按照http指示的生命周期缓存起来，以便下次用户访问时，直接返回。

![image-20211116212458789](https://gitee.com/huangwei0123/image/raw/master/img/image-20211116212458789.png)

整个项目的架构：

![image-20211116212542659](https://gitee.com/huangwei0123/image/raw/master/img/image-20211116212542659.png)

Cache Control响应头

**Cache Control状态标志着缓存的策略**

- private：客户端可以缓存
- public：客户端和代理服务器都可以缓存（代理服务器指的是从客户端到服务器经过所有的中间服务器结点，比如nginx,CDN,正向代理服务器等）
- max-age=xxx：缓存的内容将在xxx秒后失效
- no-cache：强制向服务端再验证一次（客户端缓存在本地，下次使用缓存时要向服务器请求验证是否可以使用缓存）
- no-store：不缓存请求的任何返回内容
  

![image-20211116212902369](https://gitee.com/huangwei0123/image/raw/master/img/image-20211116212902369.png)

客户端向服务器验证是如何做的呢？

**有效性判断**

- ETag：资源唯一标识

​	将请求进行MD5或hash的加密，生成一串资源唯一标识符

​	下次请求时，发送HTTP请求带上ETag，与服务器本地关于ETag做验证，符合就返回`状态码304(NOT Modified)` ，表示缓存客户端可以直接使用

- If-None-Match：客户端发送的匹配ETag的标识符
- Last-modified：资源最后被修改的时间
- if-Modified-Since：客户端发送的匹配资源最后修改时间的标识符



**整个客户端向浏览器请求流程如下**：

![image-20211116213418099](F:\java书籍\Family\文章\秒杀项目.assets\image-20211116213418099.png)

首先请求用户资源，

1、先判断URL本地是否有缓存，如果没有直接向服务器请求，然后返回。

2、如果有，判断缓存的过期时间（max-age），没有过期，直接使用缓存资源

3、如果有max-age但过期，则优先判断ETag：有的话向服务器请求if-None-Match，请求带上ETag

4、没有ETag，判断是否有Last-modified，然后向服务器请求If-modified-since（客户端发送的匹配资源最后修改时间如果早于资源修改的时间Last-modified，则表示无效，已被修改，如果晚于则有效）

5、服务器返回的304表示资源未被修改，本地缓存可以直接使用；如果返回200，表示资源被修改，向服务器发起请求；

#### 2、浏览器的三种刷新方式

1、回车刷新或者a标签：看cache-control对应的max-age是否有效，有效就直接使用本地缓存，如果cache-control为no-cache，则进入`缓存协商逻辑`（去判断ETag或者Last-modified这种方式）

2、F5刷新或者Command+R刷新：去掉cache-control中的max-age或者直接设置为0，然后进入`缓存协商逻辑`

3、强制刷新ctrl+F5或者Command+shift+R刷新：去掉cache-control和协商头（带ETage或Last-Modified），强制刷新，从服务器获取资源。

**缓存协商机制：比较last-modified和ETag到服务端，若服务端判断没变化则304不返回数据，否则200返回数据**

#### 3、静态资源CDN部署策略

如果静态文件（CSS、JS、img）文件名不变，采用max-age设置缓存时间后，如果在缓存有效期内发生版本更新，比如**重大故障**或者更新，如果全部是让用户来手动刷新浏览器，清缓存，这样体验不好，参考下面部署方式：

1、**css,js,img等元素使用带版本号部署，例如a.js?v=1.0不便利，且维护困难**（如果单纯改某个文件版本，其他文件是否更新版本号会难以维护）

html内嵌css,js,img这些资源，必须设置成`no-cache`，向服务器做缓存协商机制。html一般采用**强推**的概念，可以设置max-age，但每次请求都会让CDN全部失效，然后回源，这样将max-age设置一个短的时间后，用户就有版本更新

2、**css,js,img等元素使用带摘要部署：例如a.js?v=45edw存在先部署html还是先部署资源的覆盖问题；**

给资源文件名后加一个部署摘要（一段字符串，如果文件没变化，摘要也不改变），但会存在问题。

1） 情况1-先部署资源文件后部署html

某个js文件发生变化，更改摘要后如果js先部署，js会覆盖老版本，此时html引用的还是老js，有可能导致不兼容问题；

2） 情况2-先部署html后部署资源文件

先部署html会引用新的js,而此时服务器还是老的js等，容易出错

3、**（推荐）css,js,img等元素使用摘要做文件名部署，例如45edw.js,新老版本并存，且可回滚，资源部署完成后再部署html；**

#### 4、全页面静态化是怎么实现的？

html,css,js静态资源cdn化 -->js ajax动态请求cdn化（将请求变成静态文件发送到cdn）–>全页面静态化

**定义**：在服务端完成html，css，甚至js的load渲染成纯html文件后直接以静态资源的方式部署到cdn上

**phantomjs**
首先phantomjs是一个无头浏览器，可以借助其模拟webkit js 的执行

- 修改需要全页面静态化的实现，采用initView和hasInit方式防止多次初始化
- 编写对应轮询生成内容方式
- 将全静态化页面生成后推送到cdn
- **总结：经过全页面静态化以后，从以前刷新ajax请求填充到html这个过程变成了已经执行好的静态html页面**

在项目里面就是：

1、将getItem.html中的 获取商品详情的ajax操作在服务端/爬虫端执行掉

2、执行完成后，依赖于爬虫生成一个已经将数据加载好的静态资源文件（执行了里面的reloadDom()方法）

3、将静态资源文件部署到CDN上，完成全页面静态化操作

```javascript
var page = require("webpage").create();
var fs = require("fs");
// 类似导包一样的操作
page.open("http://miaoshaserver/resource/getitem.html?id=6",function(status){
    console.log(status);
    var isInit = "0";
    // 要设置延迟时间，先要将css和js加载完，才会去给你发请求然后写入文件
    setInterval(function(){
        if(isInit != "1"){
            page.evaluate(function(){
               initView(); 
            });
            isInit = page.evaluate(function(){
                return hasInit();
            });
        }else {
             // 将执行上述请求后的静态文件，以页面的方式写出到getItemPhantom.html
        	fs.write("getItemPhantom.html",page.content,"w");
        	phantom.exit();
        }
       
    },1000);
})


//但是会出现刷新后还是会发出ajax请求，这是为什么呢？
//是因为当js中的reloadDom()已经在我们的无头浏览器phantom中执行一次后，用户用真浏览器打开后，js又被执行了一次，我们需要使用initView和hasInit的方式来控制

//在getItem.html中
<input type='hidden' id='isInit' value='0'>
function hasInit(){
    var isInit = $("#isInit").val();
	return isInit;
}

function setHasInit(){
    $("#isInit").val("1");
}

function initView(){
    var isInit = hasInit();
    if(isInit == "1"){
        return;
    }
    //要执行的ajax请求代码
    
    //无头浏览器做完后，将初始化值设置为1，用户浏览器打开的时候就不会去触发这个ajax请求了
    setInit();
}
```

