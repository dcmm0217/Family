# 秒杀项目



## 1、分布式会话是怎么实现的，为什么要用分布式会话？

#### 1、为什么？

因为我们项目使用了2台应用服务器做了负载均衡和反向代理。如果还是单机版Session的情况，会出现

**在A1系统登录后创建并保存Session，再次发起请求，请求被转发到A2系统上显示未登录的情况**

**所以我们需要把生产的SessionId存到Redis中**

#### 2、实现步骤：

首先我们引入两个Jar包

```xml
<!--redis-->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-redis</artifactId>
    <version>2.3.1.RELEASE</version>
</dependency>
<!--将session 放入redis-->
<dependency>
    <groupId>org.springframework.session</groupId>
    <artifactId>spring-session-data-redis</artifactId>
    <version>2.0.5.RELEASE</version>
</dependency>
```

并且新建一个`RedisConfig`类，暂时不进行任何操作只添加两个注解

```java
@Component
@EnableRedisHttpSession(maxInactiveIntervalInSeconds = 3600)
```

并在properties中添加redis相关配置

```properties
# redis配置
spring.redis.host=（对应服务器主机ip）
spring.redis.port=6379
spring.redis.database=10

# 设置jedis 连接池
spring.redis.jedis.pool.max-active=50
spring.redis.jedis.pool.min-idle=20
```

由于登录时我们将`UserModel`存在session中，现在存储在`redis`中，我们要给`UserModel`**配置序列化操作**。

```
为什么存储到Redis要将实体类进行序列化？
1、任何存储都需要序列化。
2、只不过常规你在用DB一类存储的时候，这个事情DB帮你在内部搞定了（直接把SQL带有类型的数据转换成内部序列化的格式，存储；读取时再解析出来）。
3、redis又不是java专用的，它不支持java特有的数据类型。Redis并不会帮你做这个事情。当你用Redis的key和value时，value对于redis来讲就是个byte array。
```

**登录时，我们生产Token，将其代表`sessionId`与`UserModel`以键值对的形式存入`Redis`中**

```java
String uuidToken = UUID.randomUUID().toString().replaceAll("-","");
// 建立token和用户登录态之间的联系
redisTemplate.opsForValue().set(uuidToken,userModel,1, TimeUnit.HOURS);

// 返回给前端
return CommonReturnType.create(uuidToken);
```

```javascript
// 如果登录成功，则将后端返回的token存放到localStorage里面。
if (data.status == "success") {
    alter("登录成功");
    var token = data.data;
    window.localStorage["token"] = token;
    window.location.href = "listitem.html";
}
```

前端要下单时

```javascript
$("#createorder").on("click", function () {
    var token = window.localStorage["token"];
    if (token == null) {
        alert("没有登录不能下单");
        window.location.href = "login.html";
        return false;
    }
    $("#verifyDiv img").attr("src","http://" + g_host + "/order/generateVerifyCode?token="+token);
    $("#verifyDiv").show();
});
```

后端下单校验用户是否登录

```java
String token = request.getParameterMap().get("token")[0];

if (StringUtils.isEmpty(token)) {
    throw new BusinessException(EmBusinessError.USER_NOT_LOGIN, "用户还未登录,不能下单");
}
//从redis中拿到对应uuid的userModel
UserModel userModel = (UserModel) redisTemplate.opsForValue().get(token);
if (userModel == null) {
    throw new BusinessException(EmBusinessError.USER_NOT_LOGIN, "用户还未登录,不能下单");
}
```

分布式会话，有两种常见的实现方式：

1. 第一种是通过Spring提供的API，将Tomcat的`SessionId`和`UserModel`存到Redis服务器上。
2. 第二种是通过UUID生成登录`token`，将`token`和`UserModel`存到Redis服务器上。



## 2、看你项目上说用到了多级缓存？是怎么用的？为什么要用呢?

首先要明白使用缓存的目的，主要是**提高查询效率**。减少数据库的压力，提高系统的QPS

```
1、Redis缓存
2、热点内存本地缓存（JVM）
3、nginx proxy cache 缓存
4、nginx lua 缓存

```

#### Redis缓存

- 单机版
- sentinal哨兵模式
- 集群cluster模式

我们采用单机版对查询进行缓存

item商品信息，会查询3张表，首先是item**基础信息表**，然后是**库存表**，再者是**promo活动表**（该商品是否参与秒杀活动），故很消耗Mysql的性能，我们采用缓存的方式如果其id相同，则返回相同的Model即可。

**我们采用item_id，表示Item商品+商品id 代表其key；**

Value即是我们的UserModel对象。

**当我们访问商品时，我们先从redis中获取，如果redis中没有，则访问数据库获取，并且写回到redis；**

```java
// ItemController代码
// 根据redis 获取商品 Model
ItemModel itemModel = (ItemModel) redisTemplate.opsForValue().get("item_" + id);
// 若不存在
if(itemModel == null){
    itemModel=itemService.getItemById(id);
    // 将其放入Redis
    redisTemplate.opsForValue().set("item_" + id,itemModel);
    redisTemplate.expire("ietm_"+id,10, TimeUnit.MINUTES);
}
```

然后此时我们查看redis中的数据时是乱码的形式，原因为我们没有配置其序列化格式，其采用自己的一种编码方式

```java
public class RedisAutoConfiguration {
    @Bean
    @ConditionalOnMissingBean(
        name = {"redisTemplate"}// 此注解代表 当我们spring容器中没有redistemplate Bean时，其自动给我们配置此编码格式的Bean
    )
    public RedisTemplate<Object, Object> redisTemplate(RedisConnectionFactory redisConnectionFactory) throws UnknownHostException {
        RedisTemplate<Object, Object> template = new RedisTemplate();
        template.setConnectionFactory(redisConnectionFactory);
        return template;
}
```

此时我们自己配置一个Bean并且解决Reids序列化的问题

```java
@Bean
public RedisTemplate redisTemplate(RedisConnectionFactory redisConnectionFactory){
    RedisTemplate redisTemplate = new RedisTemplate();
    redisTemplate.setConnectionFactory(redisConnectionFactory);

    //首先解决key的序列化格式
    StringRedisSerializer stringRedisSerializer = new StringRedisSerializer();
    redisTemplate.setKeySerializer(stringRedisSerializer);

    //解决value的序列化格式
    Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(Object.class);

    //解决日期的序列化格式
    ObjectMapper objectMapper = new ObjectMapper();
    SimpleModule simpleModule = new SimpleModule();
    simpleModule.addSerializer(DateTime.class, new JodaDateTimeJSONSerializer());
    simpleModule.addDeserializer(DateTime.class, new JodaDateTimeDeserializer());

    objectMapper.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL);
    objectMapper.registerModule(simpleModule);

    jackson2JsonRedisSerializer.setObjectMapper(objectMapper);
    redisTemplate.setValueSerializer(jackson2JsonRedisSerializer);
    return redisTemplate;
}

// 对于日期而言，序列化后是一个很长的毫秒数。我们希望是yyyy-MM-dd HH:mm:ss的格式，还需要进一步处理。新建serializer包，里面新建两个类。
public class JodaDateTimeJSONSerializer extends JsonSerializer<DateTime> {
    @Override
    public void serialize(DateTime dateTime, JsonGenerator jsonGenerator, SerializerProvider serializerProvider) throws IOException {
        jsonGenerator.writeString(dateTime.toString("yyyy-MM-dd HH:mm:ss"));
    }
}
public class JodaDateTimeDeserializer extends JsonDeserializer<DateTime> {
    @Override
    public DateTime deserialize(JsonParser jsonParser, DeserializationContext deserializationContext) throws IOException, JsonProcessingException {
        String dateString = jsonParser.readValueAs(String.class);
        DateTimeFormatter formatter=DateTimeFormat.forPattern("yyyy-MM-dd HH:mm:ss");
        return DateTime.parse(dateString,formatter);
    }
}
```

#### 使用本地缓存优化

虽然Redis很好，但是还是涉及网络的IO，没有本地缓存快，我们在Redis之前添加一层**本地热点**，所谓本地，就是利用本地 JVM的内存，所谓热点，由于 JVM 内存有限，仅存放多次查询的数据（一般是一秒内上 千 甚至上万的访问）。

每个本地缓存也就是存储在各自服务器的，所以我们对脏数据也不是特别敏感，但是一定要有过期时间，并且要设置的比较短。

这里本地缓存我们可以使用`HashMap`,但是其不能支持并发修改，故我们可以选取`ConcurrentHashMap`但是无法高效处理**过期时限**、没有**淘汰机制**等问题，所以这里使用了`Google`的`Guava Cache`方案。**本质上也是一种可并发的hashmap**

```xml
// 配置Guava依赖
<dependency>
    <groupId>com.google.guava</groupId>
    <artifactId>guava</artifactId>
    <version>19.0</version>
</dependency>
```

封装本地缓存的Service接口

```java
//封装本地缓存操作类
public interface CacheService {
    //存方法
    void setCommonCache(String key,Object value);

    //取方法
    Object getFromCommonCache(String key);
}
```

其实现类

```java
@Service
public class CacheServiceImpl implements CacheService {

    private Cache<String,Object> commonCache = null;

    @PostConstruct
    //springbean会在对应bean加载的时候，优先执行对应的init方法
    public void init(){
        commonCache = CacheBuilder.newBuilder()
                //设置缓存容器的初始容量为10
                .initialCapacity(10)
                //设置缓存中最大的可以存放的key，超过100个会按照lru的策略移除缓存项
                .maximumSize(100)
                //设置写缓存后多少秒过期
                .expireAfterWrite(60, TimeUnit.SECONDS).build();
    }

    @Override
    public void setCommonCache(String key, Object value) {
        commonCache.put(key,value);
    }

    @Override
    public Object getFromCommonCache(String key) {
        return commonCache.getIfPresent(key);
    }
}
```

**在获取商品id详情时，先走本地缓存 --- Redis缓存 -- mysql服务器**

```java
//商品信息浏览
@GetMapping(value = "/get")
@ResponseBody
public CommonReturnType getItem(@RequestParam("id")Integer id){
    //多级缓存 优化访问策略   1、本地缓存  2、redis缓存 3、数据库
    ItemModel itemById = null;
    //先去本地缓存
    itemById = (ItemModel) cacheService.getFromCommonCache("item_"+id);
    if (itemById==null){
        //根据商品的id到redis内获取对应的UserModel
        itemById = (ItemModel) redisTemplate.opsForValue().get("item_" + id);
        //若redis内不存在对应的itemModel，则访问下游的service
        if (itemById==null){
            itemById = itemService.getItemById(id);
            //设置itemModel到redis内
            redisTemplate.opsForValue().set("item_"+id,itemById);
            //缓存一定要记得设置过期时间,不仅仅是为了redis的一个容量性能考虑，更为了业务的能力，
            //当我们的数据发生改变，就需要一个清理缓存的机制
            redisTemplate.expire("item_"+id,10, TimeUnit.MINUTES);
        }
        //设置本地缓存
        cacheService.setCommonCache("item_"+id,itemById);
    }
    ItemVO itemVO = convertVOFromModel(itemById);
    return CommonReturnType.create(itemVO);
}
```

至此**tps**能最高到达**4000**，并且保持在**50ms**以内，因为大部分重复的访问全部走向了**本地缓存**，对服务器没有一点压力

**本地缓存的缺点：**

1、更新特别麻烦，容易产生脏缓存

2、受到 JVM 容量限制

#### Nginx Proxy Cache缓存

**启用nginx缓存的条件：**

- nginx可以用作反向代理
- 依靠文件系统存索引级的文件(将请求存成本地文件，在本地磁盘中)
- 依靠内存缓存文件地址（接下来有点绕：内存缓存文件的内容value是以文件形式存放在磁盘中，但是缓存的key以缓存的方式在内存中，缓存key在内存的内容就是 —内存缓存文件的地址）也就是说nginx proxy cahce 寻址的key在内存当中，value在磁盘中，key内存中存储的是value的地址
  

通过**Redis缓存**减少了**MySQL的重复查询**，通过**本地缓存**，减少了Redis的**网络I/O**，大大的提高了效率，但是客户端请求Nginx服务器也有分发过程，需要去请求后面的两台应用服务器，有一定网络I/O，我们可以直接把**热点数据**存放到**Nginx服务器**上。

通过`Nginx Proxy Cache`作为文件存放在指定目录下。

```shell
# 申明一个cache缓存节点 evels 表示以二级目录存放
    proxy_cache_path /usr/local/openresty/nginx/tmp_cache levels=1:2 keys_zone=tmp_cache:100m inactive=7d max_size=10g;
...
server{
    location / {
        #proxy_cache 目录
        proxy_cache tmp_cache;
        proxy_cache_key $uri;
        #只有后端返回以下状态码才缓存
        proxy_cache_valid 200 206 304 302 7d;
    }
}
```

sbin/nginx -s reload重启服务器

这样在tmp_cache/下生成了对应的文件为JSON格式。

但是不好用，它是放在本地磁盘上的，有磁盘I/O，而且一般企业级都是用到的NAS。 一般很少使用。

#### nginx lua脚本

协程机制：

- 依附于线程的内存模型，切换开销小
- 遇阻塞及归还执行权，代码同步
- 无需加锁

后2种方式属于服务器的优化了。

## 3、CDN

