## 阿里开发规范，为啥禁用外键约束？

以及为啥禁用级联删除与级联更新操作

触发器也不能使用是为什么？

#### 1、什么是外键约束？

**外键约束**（也称为 引用约束 或者是引用完整性约束）可定义表间以及表内必须的关系。

引用完整性是数据库的一种状态，在该状态中，所有外键的所有值都有效。外键是表中的一列或一组列，它的值需要与其父表的行的至少一个主键或者唯一键相匹配。引用约束是这样一种规则，仅当满足下列其中一个条件时 ，外键的值才有效。

- 它们作为父键的值出现
- 外键的某些组成部分为空

![image-20210907121554730](阿里开发规范，为啥禁用外键约束.assets/image-20210907121554730.png)

外键并不是通过列名实现的，而是通过定义外键约束实现的：

```sql
ALTER TABLE students
ADD CONSTRAINT fk_class_id
FOREIGN KEY (class_id)
REFERENCES classes (id);
```

==通过定义外键约束，关系数据库可以保证无法插入无效的数据。即如果`classes`表不存在`id=99`的记录，`students`表就无法插入`class_id=99`的记录==

由于外键约束会降低数据库的性能，大部分互联网应用程序为了追求速度，并不设置外键约束，而是仅靠应用程序自身来保证逻辑的正确性。这种情况下，`class_id`仅仅是一个普通的列，只是它起到了外键的作用而已。

**（用类似外键的列，来关联另外的表，起到外键的作用，靠程序自身的校验来保证逻辑的正确性）**

要删除一个外键约束，也是通过`ALTER TABLE`实现的：

```sql
ALTER TABLE students
DROP FOREIGN KEY fk_class_id;
```

注意：删除外键约束并没有删除外键这一列。删除列是通过`DROP COLUMN ...`实现的。

#### 2、什么是级联操作？

级联操作一般发生在存在一对一、一对多、或者多对多的对应外键关系中，

有级联更新、级联删除

在删除父表中的数据的时候，级联删除子表中的数据`on delete cascade`

在更新父表中的数据时候，级联更新子表中的数据`on update cascade`

级联操作在外键约束后面添加

```sql
CREATE TABLE students(
	id INT,
    class_id INT,
    name VARCHAR(10),
    INDEX(class_id),
    PRIMARY KEY(id),
    FOREIGN KEY (class_id) REFERENCES classes (id)
    ON DELETE CASCADE ON UPDATE CASCADE
);
```

```sql
ALTER TABLE students
ADD CONSTRAINT fk_class_id
FOREIGN KEY (class_id)
REFERENCES classes (id)
ON DELETE CASCADE ON UPDATE CASCADE;
```



#### 3、Mysql的触发器是什么？

在某一个字段上绑定的某一个触发条件，就叫触发器。

#### 4、为啥要禁用级联删除各更新？

主要的就是  级联删除会让数据流向变得不可控。我只删某一条数据，但是级联的存在，会把关联的数据全部自动删掉。

#### 5、为什么要禁用外键约束？ 

1、最主要的是外键的一个性能问题

- 数据库需要维护外键的内部管理，消耗性能
- 外键等于把数据的一致性事务实现，全部交给数据库服务器完成（一般选择在代码层面去控制，进行分离是最好的）
- 有了外键，当做一些涉及外键字段的增、删、更新操作之后，需要触发相关操作去检查，而不得不消耗资源，从而降低性能
- 外键还会因为需要请求对其他表内部加锁 而 容易出现死锁的情况

2、用户量大、高并发的业务场景不适合

- 对外键字段的CRUD，会出现触发其他相关操作去检查，维护数据的一致性，这样数据库很容易出现性能瓶颈，尤其受IO能力限制，且不能轻易的水平扩展；
- 若是把数据一致性的控制放到事务中，也能让应用服务器承担此部分的压力。而应用服务器一般都是可以做到轻易的水平伸缩。
- **并发问题，外键约束会启用行级锁，主表写入时会进入阻塞**
- **详细过程**，订单明细表的订单ID,和订单表的ID户互为主外键，当你在订单明细表去新增多条数据的时候，会去查询订单表的主键ID（共享锁），看订单明细表的订单ID是否存在，如果在同时，因为不知名原因，有请求去修改订单表对应的某个数据，这时 订单表会被（排它锁）锁定，而导致所有订单明细表的写操作阻塞，容易造成线程积压，如果在高并发环境，可能会出现服务崩溃的现象。

**3、有了外键约束，每次DELETE或者UPDATE都必须考虑外键约束，会导致开发的时候很痛苦，测试数据极为不便。**

4、**数据量特别特别大的时候，需要去换一种非关系型的数据库**，HBase等。进行了数据迁移以后，数据类型不一样了，而且不在同一个数据库里面了，主外键直接失效，如果程序中又没有添加数据一致性的校验的话，数据就会出现很大问题，我们又不得不在code层面去添加一致性校验。

**适合场景**

1、软件应用的人数有限。总用户量不高而且可控

2、数据库服务器的数据量也不会超大，且活跃数据有限

3、不用考虑数据库性能的问题

**外键的好处**

1、保证数据的完整性和一致性

2、级联操作方便

3、数据一致性交给数据库，减少代码量
