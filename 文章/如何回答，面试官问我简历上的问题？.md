## 假设我是面试官，我会问这份简历什么问题？

## 1、基础技能

> 1.1 Java集合

**1、看简历上你说你熟悉Java集合，那你说说看，集合的一个整体的结构是什么样子的。**

xx：好的，Java集合主要有2大类、一是Collection、二是Map、首先有一个顶级父接口Iterable,Collection继承了Iterable，在Collection下又有List、Queue、Set三个子接口，

List的实现类主要有ArrayList、Vecter、LinkedList；

Queue的实现类主要有ArrayDeQue、PriorityQueue；

Set的实现类主要有TreeSet、HashSet、LinkedHashSet

Map集合的主要实现类有 HashMap、LinkedHashMap、HashTable



**2、好，那你说说List,Set,Map三者的区别？**

- List主要存放有序、可重复的数据（对付顺序的好帮手）
- Set存储的是无序、不可重复的数据（注重独一无二的属性）
- Map使用键值对存储，key是无序、不可重复的，value是无序、可重复的，每个键最多映射一个值。



**3、ArrayList、LinkedList、Vector有什么区别呢？**

- 数据结构分析：ArrayList底层是Object[10] 数组，LinkedList底层采用的是双向链表，Vector采用的是Object[10] 数组

- 插入和删除是否受元素位置的影响：

  ```
  ArrayList 采⽤数组存储，所以插⼊和删除元素的
  时间复杂度受元素位置的影响。 ⽐如：执⾏ add(E e) ⽅法的时候， ArrayList 会默认在将
  指定的元素追加到此列表的末尾，这种情况时间复杂度就是 O(1)。但是如果要在指定位置 i
  插⼊和删除元素的话（ add(int index, E element) ）时间复杂度就为 O(n-i)。因为在进⾏上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执⾏向后位/向前移⼀位的操作。
  
  LinkedList 采⽤链表存储，所以对于 add(E e) ⽅法的插⼊，删除元素时间复杂度不受元素
  位置的影响，近似 O(1)，如果是要在指定位置 i 插⼊和删除元素的话（ (add(int index, E
  element) ） 时间复杂度近似为 o(n)) 因为需要先移动到指定位置再插⼊。
  ```

- 是否支持快速随机访问：LinkedList不支持高效的随机访问，而ArrayList是支持的。快速随机访问就是通过元素的序号快速获取元素对象（get方法）
- 内存空间占用：arrayList的空间浪费主要体现在在集合尾部会预留一定容量的空间，而Linkedlist 的空间花费则体现在每一个元素都要消耗比ArrayList更多的空间，因为是采用双向链表存储，每个结点上都会有前驱和后继结点以及数据

- 是否线程安全：ArrayList、LinkedList都是线程不安全的，Vector是线程安全的

**4、那你知道ArrayList是怎么扩容的吗？**

其实ArrayList扩容的本质就是计算出新的扩容数组的size后实例化，并将原有数组内容复制到新数组中去。

```java
private void grow(int minCapacity) {
    // 获取到ArrayList中elementData数组的内存空间长度
    int oldCapacity = elementData.length;
    // 扩容至原来的1.5倍
    int newCapacity = oldCapacity + (oldCapacity >> 1);
    // 再判断一下新数组的容量够不够，够了就直接使用这个长度创建新数组，
    // 不够就将数组长度设置为需要的长度
    if (newCapacity - minCapacity < 0)
    newCapacity = minCapacity;
    //若预设值大于默认的最大值检查是否溢出
    if (newCapacity - MAX_ARRAY_SIZE > 0)
    newCapacity = hugeCapacity(minCapacity);
    // 调用Arrays.copyOf方法将elementData数组指向新的内存空间时newCapacity的连续空间
    // 并将elementData的数据复制到新的内存空间
    elementData = Arrays.copyOf(elementData, newCapacity);
}

// 判断是否要扩容的方法
private void ensureExplicitCapacity(int minCapacity) {
    modCount++;

    // 如果最小需要空间比elementData的内存空间要大，则需要扩容
    if (minCapacity - elementData.length > 0)
        //扩容
        grow(minCapacity);
}
```

**5、能聊一下HashMap吗?**

- HashMap是Map接口的实现类，是key，value键值对类型的集合，

**6、HashSet是如何检查重复的?**

**7、ConcurrentHashMap和HashMap有什么区别？**

**8、ConcurrentHashMap线程安全的是什么实现的？**