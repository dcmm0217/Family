# 接口防重设计

## 1、前言

在业务设计中防重设计是一个关键点，以接口设计为例，==防重就是防止接口被多次调用而产生脏数据==，比如支付订单出现重复支付，所以说防重至关重要，在如何防重之前我们首先看一下是如何出现重复请求的。

要区分防重和幂等的区别：

防重：==指重复多次提交同样的交易指令或者订单请求到后台，系统必须能够去重，防止重复执行。一般直接return==

幂等：==是在多个同样的交易指令或请求同时或者先后到达后台，**即使重复执行**，系统也必须始终提供与一致的状态，而不能有其他的副作用。（走完业务逻辑，但是不产生副作用。）==

## 2、何时出现重复调用

多次调用接口的出现有主观原因比如：人为的重复请求攻击，用户的误操作等；也有客观原因比如：为了健壮性进行超时重试；

- 重复请求攻击

​	对于这种恶意攻击，其实已经属于安全范畴了，我们可以通过IP黑名单+限流（RateLimiter）来处理，下一步再考虑防重处理；

- 用户的误操作

​	比如用户在界面点击提交按钮，因为手误出现多次点击提交，这种情况客户端可以做一些处理，减少用户的误操作，比如提交完按钮变	灰等；当然提供方的防重处理也是必不可少的；

- 超时重试

​	接口调用方为了保证系统的健壮性，往往会做一些重试处理，比如各种RPC框架都已经帮我们内置了容错机制，提供方需要做好防重；

## 3、何时需要防重

所有的操作说到底都是增删改查，其实我们真正需要做防重处理的，更重要的是增加和修改

查询和删除本身执行一次和多次，产生的效果是一样的，有天然幂等性，虽然说有天然幂等性

但是查询和删除本身也是要消耗资源的，如果能防止重复执行，也能节省资源； 增加和修改是必须要做防重的，增加可以以下单为例，修改可以以更新库存为例，如果没有做好防重后果是非常严重的；下面具体看看都有哪些防重的措施

## 4、防重方案

#### 4.1 统一防重

- token机制

服务器需要提供获取token机制的服务，这样每次客户端请求的时候先获取token，服务器端会将token保存在redis中；客户端发送请求的时候会带上token，这样服务器端可以拿到token直接去redis中做删除处理，根据返回值判断是否成功：

- 防重key

根据请求参数生成md5密文，然后用此密文作为key存入redis中，可以通过使用setnx命令来保证只有一个能保存成功；

```java
key = MD5.md5("param1="+param1+"&param2="+param2...)
或 key作为一个唯一流水号也行
```

根据setnx的命令返回值来进行判断是否重复。

如果返回1 说明第一次请求，放行。 如果返回0 说明已经请求过了， 直接return。

- 防重表

可以利用表的唯一索引约束，可以使用类似防重key作为唯一索引字段，多次请求过来只会有一个插入成功，为了防止防重表数据过多，可以启动一个定时器定时清理；

#### 4.2 业务防重

- 唯一键处理

使用分布式id算法生成业务唯一标识，直接插入请求，这样在插入数据的时候就可以通过唯一键来进行约束，保证只会有一条成功；

```java
Rsp idempotent（Request req）{
  // 组装一个DAO(带上业务唯一键)
  try{
    insert(dao);
  }catch(DuplicateKeyException e){
     //拦截是重复请求，直接返回成功
    log.info("唯一键冲突，是重复请求，直接返回");
    return rsp;
  }
```



