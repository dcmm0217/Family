## 假设我是面试官，我会问这份简历什么问题？

## 1、基础技能

### 1.1 Java集合

#### **1、看简历上你说你熟悉Java集合，那你说说看，集合的一个整体的结构是什么样子的。**

xx：好的，Java集合主要有2大类、一是Collection、二是Map、首先有一个顶级父接口Iterable,Collection继承了Iterable，在Collection下又有List、Queue、Set三个子接口，

List的实现类主要有ArrayList、Vecter、LinkedList；

Queue的实现类主要有ArrayDeQue、PriorityQueue；

Set的实现类主要有TreeSet、HashSet、LinkedHashSet

Map集合的主要实现类有 HashMap、LinkedHashMap、HashTable



#### **2、好，那你说说List,Set,Map三者的区别？**

- List主要存放有序、可重复的数据（对付顺序的好帮手）
- Set存储的是无序、不可重复的数据（注重独一无二的属性）
- Map使用键值对存储，key是无序、不可重复的，value是无序、可重复的，每个键最多映射一个值。



#### **3、ArrayList、LinkedList、Vector有什么区别呢？**

- 数据结构分析：ArrayList底层是Object[10] 数组，LinkedList底层采用的是双向链表，Vector采用的是Object[10] 数组

- 插入和删除是否受元素位置的影响：

  ```
  ArrayList 采⽤数组存储，所以插⼊和删除元素的
  时间复杂度受元素位置的影响。 ⽐如：执⾏ add(E e) ⽅法的时候， ArrayList 会默认在将
  指定的元素追加到此列表的末尾，这种情况时间复杂度就是 O(1)。但是如果要在指定位置 i
  插⼊和删除元素的话（ add(int index, E element) ）时间复杂度就为 O(n-i)。因为在进⾏上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执⾏向后位/向前移⼀位的操作。
  
  LinkedList 采⽤链表存储，所以对于 add(E e) ⽅法的插⼊，删除元素时间复杂度不受元素
  位置的影响，近似 O(1)，如果是要在指定位置 i 插⼊和删除元素的话（ (add(int index, E
  element) ） 时间复杂度近似为 o(n)) 因为需要先移动到指定位置再插⼊。
  ```

- 是否支持快速随机访问：LinkedList不支持高效的随机访问，而ArrayList是支持的。快速随机访问就是通过元素的序号快速获取元素对象（get方法）
- 内存空间占用：arrayList的空间浪费主要体现在在集合尾部会预留一定容量的空间，而Linkedlist 的空间花费则体现在每一个元素都要消耗比ArrayList更多的空间，因为是采用双向链表存储，每个结点上都会有前驱和后继结点以及数据

- 是否线程安全：ArrayList、LinkedList都是线程不安全的，Vector是线程安全的

#### **4、那你知道ArrayList是怎么扩容的吗？**

其实ArrayList扩容的本质就是计算出新的扩容数组的size后实例化，并将原有数组内容复制到新数组中去。

```java
private void grow(int minCapacity) {
    // 获取到ArrayList中elementData数组的内存空间长度
    int oldCapacity = elementData.length;
    // 扩容至原来的1.5倍
    int newCapacity = oldCapacity + (oldCapacity >> 1);
    // 再判断一下新数组的容量够不够，够了就直接使用这个长度创建新数组，
    // 不够就将数组长度设置为需要的长度
    if (newCapacity - minCapacity < 0)
    newCapacity = minCapacity;
    //若预设值大于默认的最大值检查是否溢出
    if (newCapacity - MAX_ARRAY_SIZE > 0)
    newCapacity = hugeCapacity(minCapacity);
    // 调用Arrays.copyOf方法将elementData数组指向新的内存空间时newCapacity的连续空间
    // 并将elementData的数据复制到新的内存空间
    elementData = Arrays.copyOf(elementData, newCapacity);
}

// 判断是否要扩容的方法
private void ensureExplicitCapacity(int minCapacity) {
    modCount++;

    // 如果最小需要空间比elementData的内存空间要大，则需要扩容
    if (minCapacity - elementData.length > 0)
        //扩容
        grow(minCapacity);
}
```

#### **5、能聊一下HashMap吗?**

- HashMap是Map接口的实现类，是key，value键值对类型的集合。

- 我说一下HashMap的底层原理吧

  - put值得过程：

    ```java
    /*
    1、HashMap通过Key得hashcode经过扰动函数经过处理后得到hash值
    2、然后通过（n-1）& hash 判断当前元素存放得位置（这里的n是指的数组的长度）
    3、如果当前位置存在元素的话，就判断该元素与要存入的元素的hash值以及key是否相同，如果相同之间覆盖，不相同就通过拉链法解决冲突。
    
    拉链法：将链表和数组相结合。创建一个链表数组，数组中的每一格就是一个链表，若遇到hash冲突，则将冲突的值加到链表中即可。
    
    扰动函数指的就是HashMap的hash方法，使用hash方法的目的就是为了减少hash碰撞，hash冲突。
    */
    static final int hash(Object key) {
     int h;
     // key.hashCode()：返回散列值也就是hashcode
     // ^ ：按位异或
     // j>ké⽆符号右移，忽略符号位，空位都以0补⻬
     return (key WX null) ? 0 : (h = key.hashCode()) ^ (h j>k 16);
     }
    ```

  - 在JDK1.8以前HashMap是采用的`数组+链表`的数据结构,JDK1.8以后又引入了红黑树的数据结构，会在链表和红黑树之间进行转换。

    ```java
    transient HashMap.Node<K, V>[] table;
    
    //HashMap定义了Node的数组，Node定义如下
    static class Node<K, V> implements Entry<K, V> {
            final int hash;
            final K key;
            V value;
            HashMap.Node<K, V> next;
            // ....省略
      }
    
    /*
    	key、value 是调用hashMap的put()方法传进来的
        hash 是判断key是否重复的关键
        next 是用于构建链表
    */
    ```

    

  - 链表是否要转成红黑树，是在调用put()方法添加数据时去判断的，源码分析 链表 -》 红黑树 的过程  put()方法调用的是putVal()

    ```java
    final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) {
        // ...省略
        while (true) {
            if ((e = ((HashMap.Node) p).next) == null) {
                ((HashMap.Node) p).next = this.newNode(hash, key, value,(HashMap.Node) null);
                //转换成红黑树
                if (binCount >= TREEIFY_THRESHOLD - 1) {
                    this.treeifyBin(tab, hash);
                }
                break;
            }
            if ((((HashMap.Node) e).hash == hash) &&
                (((k = ((HashMap.Node) e).key) == key) ||
                 ((key != null) && key.equals(k)))) {
                break;
            }
            p = e;
            ++binCount;
        }
        // ...省略
    }
    /*
    	while 循环中遍历链表中的数量，如果数量大于等于 8，调用treeifyBin()方法
    	在treeifyBin()中有一行,hd.treeify(tab);
    	treeify()方法会将链表转换为红黑树。同时会将链表中所有节点由Node结构转换为TreeNode结构
    	如果链表长度 > TREEIFY_THRESHOLD - 1 时，开始树化，  当红黑树长度 < UNTREEIFY_THRESHOLD(6) 时转化成链表
    */
    
    /*
    	put的流程：
    	1、判断tab是否为空，如果为空，说明table还未初始化，先对数组进行初始化。
    	2、先计算在数组中的位置，并对该位置进行判空处理，如果为空，直接赋值，然后判断是否需要扩容
    	3、如果位置不为空，判断节点key是否存在，如果存在直接赋值，不存在则执行 第四步
    	4、判断是否为红黑树，如果是则添加到树中，不是则执行 第五步
    	5、如果是链表，则判断长度是否大于等于TREEIFY_THRESHOLD - 1，如果是先将链表转化成红黑树，然后添加到树中，如果不是则添加到链表尾部。
    	6、插入成功后，判断实际存在的键值对数量size是否超过了最大容量threshold,如果超过，进行扩容。
    */
    
    
    ```

  - HashMap是怎么样扩容的？

    ```java
    /*
    	扩容的流程：
    	1、当 HashMap 键值对大于阀值时或者初始化时，会进行扩容。阀值是threshold的值，是由数组的长度和loadFactor(默认值是0.75)决定的，threshold = length * loadFactor
    */
    
    // 初始化变量
    int oldCap = (oldTab == null) ? 0 : oldTab.length; //现在容器的大小
    int oldThr = threshold; //现在的阀值
    int newCap  //计算过后，新的容器的大小
        , newThr = 0; //计算后阀值的大小
    //注意： 扩容不只是改变容器的大小，还要改变阀值的大小
    
    
    //1、table容器不为空的情况
    if (oldCap > 0) {
        if (oldCap >=  MAXIMUM_CAPACITY) {
            this.threshold = Integer.MAX_VALUE;
            return oldTab;
        }
    
        else if ((newCap = oldCap << 1) < MAXIMUM_CAPACITY &&
                 oldCap >= DEFAULT_INITIAL_CAPACITY)
            newThr = oldThr << 1;
    }
    /*
    数量已经大于最大的容量，则将阀值设置为整数最大值，不再扩容
    newCap = oldCap << 1 扩容后仍然小于最大容量 并且 oldCap 大于默认值 16，双倍扩容阀值 threshold
    */
    
    //2、旧的容量为 0，但 threshold 大于零
    else if (oldThr > 0)
        newCap = oldThr;
    
    //出现这种情况说明有参构造有 initialCapacity 传入，那么 threshold 已经被初始化成最小 2 的 n 次幂，所以直接将该值赋给新的容量
    
    //3、旧的容量为 0，threshold 也等于 0
    else {
        newCap = DEFAULT_INITIAL_CAPACITY;
        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);
    }
    //这种情况说明是通过无参构造函数创建的，也就是Map map = new HashMap()这种格式，那么都被赋予默认的大小（默认 16）和默认的阈值（默认 16 * 0.75）
    
    //4、计算新的阈值
    if (newThr == 0) {
        float ft = (float)newCap * loadFactor;
        newThr = (newCap < MAXIMUM_CAPACITY && ft < (float)MAXIMUM_CAPACITY ?
                  (int)ft : Integer.MAX_VALUE);
    }
    //这种情况说明是在有参构造时，默认的loadFactor被重新赋值，如果loadFactor大于 1，那么阈值会比容量大，有可能会超出最大容量，所以要重新计算。
    //还有一种情况在第一步中newThr = oldThr << 1，左移超出范围后会置0，也要重新计算。
    
    //注意：扩容的大小 （newCap = oldCap << 1） << 相当于乘2,所以HashMap的容量总是2的n次方
    ```

    

  - 为什么说HashMap是线程不安全的？不安全主要体现在哪里？

    ```java
    /*
    	在HashMap的put操作里面，
    */
    if (++size > threshold)
         resize();
    
    // ++size并不是原子操作，当多个线程都执行这行代码时，会存在丢失数据的情况。
    // 当HashMap的size > capacity * loadfactor,就会要进行扩容
    ```

**6、HashSet是如何检查重复的?**

- 1、会判断对象的HashCode值来确定对象加入的位置，同时也会与其他加入的对象进行hashcode的比较，如果没有相符的hashcode，HashSet会假设对象没有重复出现，直接添加。

- 2、如果出现相同的hashcode值，这时会调用equals()方法来检查hashcode相等的对象是否真的相同，如果相同，则添加不成功。

  ```java
  1. 如果两个对象相等，则hashcode一定相等
  2. 两个对象相等，对两个对象进行equals返回true
  3. 两个对象有相同的hashcode，但不一定是相等的
  4. equals方法被覆盖过，则hashcode方法也必须被覆盖
  5. hashcode()的默认行为是对堆上的对象产生独特值。如果没有重写hashcode(),则该class的两个对象无论如何都不会相等。（即使这2个对象指向相同的数据）
      
  == 和 equals的区别
      1. == 是判断两个变量或实例是不是指向同一个内存空间，equals是判断两个变量或实例所指向的内存空间的值是不是相同。
      2. == 是对内存地址进行比较  equals()是对字符串的内容进行比较
      3. == 是指引用是否相同  equals是指的指是否相同
  ```

**7、ConcurrentHashMap和HashMap有什么区别？**

**8、ConcurrentHashMap线程安全的是什么实现的？**









## 2、项目问题

#### 1、数据库设计的时候，**为什么要将商品的库存表item_stock与商品表item分开？**

因为我们知道，在商品交易的过程中，会频繁的出现商品库存的扣减，如果把库存合并到item表，每次操作库存会将对应的行添加上行锁，**如果分开库存表，虽然每次减库存中还是会添加行锁，但是可以将这张表拆到另一个数据库中，分库分表，做效果的优化**

2、