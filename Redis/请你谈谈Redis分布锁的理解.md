# 请你谈谈Redis分布锁的理解

1、**分布式锁**：分布式锁就是分布式场景下的锁，比如多台不同机器上的进程，去竞争同一项资源，就是分布式锁。



2、**分布式锁应该有的特性：**

- 互斥性：锁的目的就是获取资源的使用权，所以只能让一个竞争者去持有锁，这一点要尽可能保证。
- 安全性：要避免死锁情况的发生。当一个竞争者在持有锁期间，由于意外崩溃而导致未能主动解锁，其持有的锁也能够被正常释放，并保证后续其他竞争者也能够继续加锁。
- 对称性（可重入性）：同一把锁，加锁和解锁的对象必须是同一竞争者，不能把其他竞争者持有的锁给释放了。
- 可靠性：需要有一定的异常处理能力，容灾能力。



3、**分布式锁的实现方式：**

分布式锁，一般会依托第三方组件来实现，而利用**Redis**实现则是工作中应用最多的一种。

我们从最基础的步骤开始，依照分布式锁的特性，层层递进，步步完善，将它优化到最优，完整地了解如何用**Redis**来实现一个分布式锁

==最简化版本==

直接用Redis的setnx命令（**setnx key value**）

**结果：**如果key不存在，则会将key设置为value，并返回1；如果key存在，不会有任务影响，返回0

基于这个特性，我们就可以用setnx实现加锁的目的：通过setnx加锁，加锁之后其他服务无法加锁，用完之后，再通过delete解锁，深藏功与名。

![image-20220224175156082](https://gitee.com/huangwei0123/image/raw/master/img/image-20220224175156082.png)

==支持过期时间的版本==

最简化版本有一个问题：

如果获取锁的服务挂掉了，那么锁就一直得不到释放，就像石沉大海，杳无音信。所以，我们需要一个超时来兜底

Redis中有expire命令，用来设置一个key的超时时间。**但是setnx和expire不具备原子性**，如果setnx获取锁之后，服务挂掉，依旧是泥牛入海

很自然，我们会想到，set和expire，有没有原子操作？

当然有，Redis早就考虑到了这种场景，推出了如下执行语句： **set key value nx ex seconds**

nx表示具备setnx特定，ex表示增加了过期时间，最后一个参数就是过期时间的值。

![image-20220224175324186](https://gitee.com/huangwei0123/image/raw/master/img/image-20220224175324186.png)

能够支持过期时间，目前这个锁基本上是能用了

**但是存在一个问题：会存在服务A释放掉服务B的锁的可能**

==**加上owner**==

试想下场景：

服务A获取了锁，由于业务流程比较长，或者网络延迟、GC卡顿等原因，导致锁过期，而业务还会继续进行。

这时候，业务B已经拿到了锁，准备去执行，这个时候服务A恢复过来并做完了业务，就会释放锁，而B却还在继续执行。



