# 消息队列的面试连环炮

## 前言

1、你用过消息队列么？

2、说说你们项目里是怎么用消息队列的？

（我们有一个订单系统，订单系统在每次下一个新订单的时候，就会发送一条消息到rocketMQ中去，后台有一个库存系统，负责获取消息，然后更新库存。）

3、为什么使用消息队列？

（问：你的订单系统不发送消息到MQ，而直接调用库存系统的一个接口，直接调用成功，库存也更新了，那就不需要使用消息队列了呀）

（可以围绕 异步、解耦、削峰三大特点来回答）

4、消息队列都有什么特点？

（围绕kafka，ActiveMQ，RabiitMQ，RocketMQ 的**吞吐量、社区活跃度、底层开发语言等特点来回答**）

5、如何保证消息队列的高可用？

6、如何保证消息不被重复消费？如何保证消息消费时的幂等性？

7、如何保证消息的可靠性传输，要是消息丢了怎么办？

8、如何保证消息的顺序性？

9、如何解决消息队列的延时以及过期失效问题？消息队列满了以后该怎么处理？有几百万消息持续积压几小时，说说怎么解决？

10、如果让你写一个消息队列，该如何进行架构设计，说一下你的思路？

面试官问的问题不是发散的，而是从点、铺开，比如先聊一聊高并发的话题，就这个话题里面继续聊聊缓存、MQ等等东西。对于每个小话题，比如说MQ，就会从浅入深。

## 1、为什么使用消息队列？

#### 1.剖析

首先明白系统中为什么要用到消息队列这种东西？

因为之前面试的大量候选人，说自己项目中用了Redis，MQ，但是其实他们并不清楚为什么要用这个东西，说白了就是为了用而用，或者是别人设计的架构，从头到尾就没有思考过。

没有对自己架构问过为什么的人，一定是平时没有思考的人，面试官对这种类型的人印象通常不好。

#### 2.解答

其实就是问问你消息队列有哪些场景，然后你项目里面的具体是什么场景，说说你在这个场景里用什么消息队列？

消息队列的场景使用场景很多，主要是有三个：解耦、异步、削峰

#### 3.解耦

**不适用MQ时**

A系统发送数据到B、C、D系统，但没有使用消息队列时候的耦合场景

![image-20220108102740348](https://gitee.com/huangwei0123/image/raw/master/img/image-20220108102740348.png)

当后面系统不断增加，比如 E，F系统的加入，以及D系统的移除

![image-20220108102817698](https://gitee.com/huangwei0123/image/raw/master/img/image-20220108102817698.png)

因为A系统和其它各种系统耦合起来，那么需要处理的事情会很多，而且每添加一个新服务就需要去修改代码。

**使用MQ后**

系统A发送一条消息，到消息队列中，哪个系统需要获取到哪里，直接从MQ中消费数据，如果新系统E加入得话，那么只需要编写代码，然后也直接从MQ中消费即可。

当系统D不需要这个数据时，那么只需要不对该消息进行消费即可。系统A不需要考虑给谁发送数据，也不需要维护这个代码，不需要考虑人家是否调用成功、失败、超时等等情况。

![image-20220108104625134](https://gitee.com/huangwei0123/image/raw/master/img/image-20220108104625134.png)

总结：通过一个MQ，发布/订阅模型（Pub/Sub模型），系统A就和其他系统彻底解耦。

需要考虑一下负责得系统中，是否有类似得场景，就是一个系统或者一个模块，调用了多个系统，互相之间得调用很复杂，维护起来很麻烦。但是其实这个调用是不需要同步调用接口的，如果用MQ给他异步化解耦，也是可以的，这个时候就可以考虑在自己的项目中，是不是可以运用MQ来进行系统的解耦。

#### 4.异步

**不用MQ的同步高延时请求场景**

下面的一个场景就是系统A，调用了其它三个系统的服务，我们发现用户在执行一个请求后，需要花费很长的时间

![image-20220108105229034](https://gitee.com/huangwei0123/image/raw/master/img/image-20220108105229034.png)

我们发现，用户执行一个接口，就需要花费350毫秒，假设我们将每个接口的耗时增加，可能会将近花费1秒，这个时候一般用户几乎不能接受，因为一般互联网类的企业，对用户的直接操作，一般要求是每个请求都必须在200ms以内完成，因为这个是对用户是无感知的

**使用MQ进行异步化**

![image-20220108105635830](https://gitee.com/huangwei0123/image/raw/master/img/image-20220108105635830.png)

系统A只需要发送消息到MQ中就直接返回了，然后其它系统各自在MQ中进行消费。用户在执行系统A的时候，就会感觉非常快就得到响应了。

#### 5.削峰

**没有用MQ的削峰**

![image-20220108110354077](https://gitee.com/huangwei0123/image/raw/master/img/image-20220108110354077.png)

一般Mysql，扛到QPS = 2000的时候就已经达到了瓶颈，如果每秒请求达到了5000的话，可能就把MySQL直接打死了。如果Mysql挂掉，整个系统就直接崩溃，无法使用。

但是中午高峰期过了以后，到下午的时候就出现了低峰期，可能也就一万用户在网站上操作，每秒的请求数量可能就50个请求，对整个系统几乎没有任何压力。

**使用MQ来进行削峰**

![image-20220108110708930](https://gitee.com/huangwei0123/image/raw/master/img/image-20220108110708930.png)

削峰就是大量的请求过来，然后MQ将其消化掉了，然后通过其它系统从MQ中取消息，在逐步进行消费，保证系统的有序运行。一般高峰期不会持续太长，在一段时间后，就会被下游系统消化掉。

## 2、消息队列有什么优点和缺点？

优点上面已经说了：解耦、异步、削峰，缺点呢？显而易见的

- 系统可用性降低：系统引入的外部依赖越多，越容易挂掉，本来你就是A系统调用BCD三个系统接口就好了，人家ABCD四个系统好好的，没啥问题，这个时候把MQ引入进来，万一MQ挂掉，整套系统也就崩了。
- 系统复杂度提高：硬生生加个MQ进来，你怎么保证消息没有重复消费？怎么处理消息丢失的情况？怎么保证消息传递的顺序性？
- 一致性问题：A系统处理完了直接返回成功，人都以为你的请求成功了，但是问题是，在BCD三个系统中，BD两个系统写库成功了，C系统写库失败了，这也会存在数据不一致的问题。
- 所以说消息队列实际上是一种**复杂的架构**，你引入它有好多好处，但是也得针对它带来的坏处做各种额外的技术方案和架构来规避掉，最后发现系统复杂性提升了一个数量级，也许是复杂10倍，**但是关键时刻，用还是得用。**

![image-20220108111854389](https://gitee.com/huangwei0123/image/raw/master/img/image-20220108111854389.png)

## 3、MQ有什么区别，以及适用场景

主流MQ包括：kafka、ActiveMQ、RabbitMQ和RocketMQ

常见的MQ其实就上面的四种

| 特性       | ActiveMQ                                                     | RabbitMQ                                                     | RocketMQ                                                     | Kafka                                                        |
| ---------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 单机吞吐量 | 万级，吞吐量比RocketMQ和Kafka要低一个数量级                  | 万级，吞吐量比RocketMQ和Kafka要低一个数量级                  | 10万级，RocketMQ也是可以支撑高吞吐的一种MQ                   | 10万级1这是kafka最大的优点，就是吞吐量高。一般配置和数据类的系统进行实时数据计算、日志采集等场景 |
| 时效性     | ms级                                                         | 微妙级，这是RabbitMQ的一大特点，就是延迟最低                 | ms级                                                         | 延迟在ms级内                                                 |
| 可用性     | 基于主从架构实现高可用                                       | 高，基于主从架构实现高可用                                   | 非常高，分布式架构                                           | 非常高，kafka是分布式的，一个数据多个副本，少数机器宕机后，不会丢失数据，不会导致不可用 |
| 消息可靠性 | 有较低的概率丢失数据                                         | 消息不丢失                                                   | 经过参数优化配置，可以做到0丢失                              | 经过参数优化配置可以做到0丢失                                |
| 核心特点   | MQ领域的功能及其完备                                         | 基于Erlang开发，所以并发能力强，性能及其好，延时很低         | MQ功能较为完善，还是分布式的，扩展性好                       | 功能较为简单，主要支持简单的MQ功能，在大数据领域的实时计算以及日志采集被大规模使用，是实时上的标准。 |
|            | 非常成熟，功能强大，在业内大量公司以及项目都有应用。  但是偶尔消息丢失的概率，并且现在社区以及国内应用都越来越少，官方社区对ActiveMQ5.X维护越来越少，而且确实主要是基于解耦和异步来用的，较少在大规模吞吐场景中使用 | erlang语言开发的，性能及其好，延时很低。而且开源的版本，就提供的管理界面非常棒，在国内一些互联网公司近几年用RabbitMQ也是比较多一些，特别适用于中小型的公司 缺点显而易见，就是吞吐量会低一些，这是因为它做的实现机制比较中，因为使用erlang开发，目前没有多少公司使用其开发。所以针对源码界别的定制，非常困难，因此公司的掌控非常弱，只能依赖于开源社区的维护。 | 接口简单易用，毕竟在阿里大规模应用过，有阿里平台保障，日处理消息上 百亿之多，可以做到大规模吞吐，性能也非常好，分布式扩展也很方便，社区维护还可以，可靠性和可用性都是OK的，还可以支撑大规模的topic数量，支持复杂MQ业务场景。 | 仅仅提供较少的核心功能，但是提供超高的吞吐量，ms级别的延迟，极高的可用性以及可靠性，分布式可以任意扩展。    同时kafka最好是支撑较少的topic数量即可，保证其超高的吞吐量。 |

综上所述：

- 一般业务要引入MQ，最早大家都用ActiveMQ，但是现在用的不多，没有经过大规模吞吐量场景的验证，社区也不是很活跃，不推荐使用
- RabbitMQ后面被大量的中小公司使用，但是erlang语言阻碍了大量的Java工程师深入研究和掌握它，对公司而言，几乎处于不可控的状态，但是RabbitMQ目前开源稳定，活跃度也表较高。
- RocketMQ是阿里开源的一套消息中间件，目前也已经经历了天猫双十一，同时底层使用Java进行开发

如果中小型企业技术实力一般，技术挑战不是很高，可以推荐，RabbitMQ。如果公司的基础研发能力很强，想精确到源码级别的掌握，那么推荐使用RocketMQ。

- 同时如果项目是聚焦于大数据领域的**实时计算，日志采集**等场景，那么Kafka是业内标准。

## 4、如何保证消息队列的高可用？

#### 1.剖析

这个问题问的很好，不会具体到哪个MQ，而是问一个整体，然后通过你使用的MQ,来谈谈你对该MQ可用性的理解

#### 2.RabbitMQ高可用

RabbitMQ是比较有代表性的，因为是基于主从做高可用性的。

RabbitMQ 三种模式：单机模式，普通集群模式，镜像集群模式

**单机模式**

就是demo级别的，一般就是本地启动后玩一玩，没有人生产环境中使用。

**普通集群模式**

- 意思就是在多台机器上启动多个RabbitMQ实例，每台机器启动一个，但是创建的Queue，只会放在一个RabbitMQ实例上，但是每个实例都同步queue的元数据，在消费的时候，实际上是连接到另外一个实例上，那么这个实例会从queue所在实例上拉取数据过来，**这种方式确实很麻烦，也不怎么好，没做到所谓的分布式，就是个普通集群**。因为这导致你要么消费每次随机连接一个实例，然后拉取数据，要么固定连接哪个queue所在实例消费数据，**前者有数据拉取的开销，后者导致单实例性能瓶颈。**
- 而且如果那个放queue的实例宕机了，会导致接下来其他实例无法从那个实例继续拉取，如果你开启了消息持久化，让rabbitmq落地存储消息的话，消息不一定会丢，等到这个实例恢复了，然后才可以继续从这个queue拉取数据。

![image-20220108142251906](https://gitee.com/huangwei0123/image/raw/master/img/image-20220108142251906.png)

​	

**集群镜像模式**

这种模式，才是RabbitMQ的高可用模式，==和普通的集群模式不一样的是，你创建的queue无论元数据还是queue里的消息都会存在与多个实例中，然后每次你写消息到queue的时候，都会自动把消息推到多个实例的queue中进行消息同步==。

这样的好处在于，你任何一个机器宕机了，别的机器都可用。坏处在于，性能开销提升，消息同步所有的机器，导致网络带宽压力和消耗增加。第二，就是没有什么扩展性科研，如果某个queue负载很重，你加机器，新增的机器也包含了这个queue的所有数据，并没有办法线性扩展你的queue。

那么如何开启**集群镜像策略**呢？就是在Rabbitmq管理后台，新增一个策略，这个策略就是镜像集群模式下的策略，指定的时候，可以要求数据同步到所有节点，也可以就要求 同步到指定数量的节点，然后再次创建queue的时候，应用这个策略，就会自动将数据同步到其他节点上去了。

![image-20220108143713766](https://gitee.com/huangwei0123/image/raw/master/img/image-20220108143713766.png)

集群镜像模式下，任何一个节点宕机了都是没问题的，因为其他节点还包含了这个queue的完整的数据，别的consumer可用到其他活着的节点上消费数据。

但是这个模式还存在问题：就是不是分布式的，如果这个queue的数据量很大，大到这个机器上的容量无法容纳的时候，此时应该怎么办？



#### 3.RocketMQ高可用

根据Broker集群中各个节点间关系的不同，Broker集群可以分为一下几类：

**单Master**

只有一个broker（其本质不能叫集群），这种方式也只能在测试时使用，生产环境下不能使用，因为存在单点问题。

**多Master**

broker集群仅由多个master构成，不存在slave。同一个Topic的各个Queue会平均分布在各个master节点上。

- 优点：配置简单，单个master宕机或重启维护对应用无影响，在磁盘配置为RAID10时，即使机器宕机不可恢复的情况下，由于RAID10磁盘非常可靠，消息也不会丢（异步刷盘丢失少量消息，同步刷盘一条不丢）性能最高
- 缺点：单台机器宕机期间，这台机器上未被消费的消息在机器恢复之前不可订阅（不可消费），消息实时性会受到影响。

> 以上优点的前提是，这些Master都配置了RAID磁盘阵列，如果没有配置，一旦出现某Master宕机，则会发送大量消息丢失的情况

**多Master多Slave模式-异步复制**

broker集群由多个master构成，每个master又配置多哥slave（在配置了RAID磁盘阵列的情况下，一个master一般配置一个slave即可）。master与slave的关系是**主备关系**，**即master负责处理消息的读写请求，而slave仅负责消息的备份与master宕机后的角色切换**。

**异步复制**即前面讲的 `复制策略`中的 `异步复制策略`,即消息写入master成功后，master立即向producer返回成功ACK，无需等待slave同步数据成功。

该模式的最大特点之一是，当master宕机后slave能够 `自动切换` 为master。不过由于slave从master的同步具有短暂的延迟（毫秒级），所以**当master宕机后，这种异步复制方式可能会存在少量消息的丢失问题。**

> slave 从master同步的延迟越短，其可能丢失的消息就越少
>
> 对于master的RAID磁盘阵列，若使用的也是异步复制策略，同样也存在延迟问题，同样也可能会丢失消息。但RAID阵列的秘诀是微秒级的（因为是由硬盘支持的），所以其丢失的数据量也会更少。

**多Master多Slave模式-同步双写**

该模式是`多Master多Slave模式`的`同步复制`实现。所谓`同步双写`,指的是消息写入master成功后，master会等待slave同步数据成功后才向producer返回成功ACK，即master与slave都要写入成功后才会返回成功ACK,也即`双写`

该模式与`异步复制模式`相比，优点事消息的安全性更高，不存在消息丢失的情况，但是单个消息的RT略高，从而导致性能要略低（**大约低10%**）

该模式存在一个大的问题：对于目前版本，master宕机后，slave`不会自动切换`到master

**最佳实践**

**一般会为Master配置RAID10磁盘阵列，然后再为其配置一个Slave，即利用了RAID10磁盘阵列的高效、安全性、又解决了可能会影响订阅的问题。**

> 1、RAID磁盘阵列的效率要高于Master-Slave集群，因为RAID是硬件支持的。也是正因为如此，所以搭建RAID的成本较高。
>
> 2、多Master+RAID阵列，与多Master多Slave集群的区别是什么？
>
> - 多master+RAID阵列，其仅仅可以保证数据不丢失，即不影响消息写入，但其可能会影响到消息的订阅。但其执行效率要远高于`多master多slave集群`
> - 多master多slave集群，其不仅可以保证数据不丢失，也不会影响消息写入。其运行效率要低于`多master+RAID阵列`



#### 4.Kafka高可用

![image-20220108150318567](https://gitee.com/huangwei0123/image/raw/master/img/image-20220108150318567.png)

kafka一个最基本的架构认识：多个broker组件，每个broker是一个节点，你创建一个topic，这个topic可以划分成多个partition，每个partition可以存在于不同的broker上，每个partition就放一部分数据。

这就是天然的分布式消息队列，就是说一个topic的数据，是分散在多个机器上的，每个机器上就放一部分数据。

实际上RabbitMQ之类的，并不是分布式消息队列，他就是传统的消息队列，只不过提供了一些集群、HA的机制而已，因为无论怎么玩，RabbitMQ一个queue的数据都放在一个节点里了，镜像集群下，也是每个节点都放这个queu的完整数据

> kafka0.8以前，是没有HA机制的，就是任何一个broker宕机了，那个broker上的partition就废了，没法读也没办法写，没有什么高可用可言。
>
> 而在0.8版本后，提供了HA机制，就是replica副本机制，每个partition的数据都会同步到其它机器上，形成自己的多个replica副本，然后所有的replica就是follower，写的时候，leader会负责数据都同步到所有的follower上，读的时候就直接读取leader上的数据即可。只能读写leader？很简单，要是你能随意读写每个follower，那么就需要保证数据一致性的问题，系统复杂度太高，很容易出问题，kafka会均匀的将一个partition的所有replica分布在不同的机器上，这样才能够提高容错性

每个副本不会存储节点的全部数据，而是数据可能分布在不同的机器上。

![image-20220108150941963](https://gitee.com/huangwei0123/image/raw/master/img/image-20220108150941963.png)

==同时多个副本中，会选取一个作为leader，其它的副本是作为follower，并且只有leader能对外提供读写，同时leader在写入数据后，它还会把全部的数据同步到follower中，保证数据的备份==。

此时，**高可用的架构就出来了**，假设现在某个机器宕机了，比如其中的一个leader宕机了，但是因为每个leader下还有多个follower，并且每个follower都进行了数据的备份，因此kafka会自动感知leader已经宕机，同时将其它的follower给选举出来，作为新的leader，并向外提供服务支持。



## 5、如果保证消息的重复消费？

面试题：如何保证消息的重复消费？如何保证消息消费的幂等性？

