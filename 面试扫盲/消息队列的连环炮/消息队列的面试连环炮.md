# 消息队列的面试连环炮

## 前言

1、你用过消息队列么？

2、说说你们项目里是怎么用消息队列的？

（我们有一个订单系统，订单系统在每次下一个新订单的时候，就会发送一条消息到rocketMQ中去，后台有一个库存系统，负责获取消息，然后更新库存。）

3、为什么使用消息队列？

（问：你的订单系统不发送消息到MQ，而直接调用库存系统的一个接口，直接调用成功，库存也更新了，那就不需要使用消息队列了呀）

（可以围绕 异步、解耦、削峰三大特点来回答）

4、消息队列都有什么特点？

（围绕kafka，ActiveMQ，RabiitMQ，RocketMQ 的**吞吐量、社区活跃度、底层开发语言等特点来回答**）

5、如何保证消息队列的高可用？

6、如何保证消息不被重复消费？如何保证消息消费时的幂等性？

7、如何保证消息的可靠性传输，要是消息丢了怎么办？

8、如何保证消息的顺序性？

9、如何解决消息队列的延时以及过期失效问题？消息队列满了以后该怎么处理？有几百万消息持续积压几小时，说说怎么解决？

10、如果让你写一个消息队列，该如何进行架构设计，说一下你的思路？

面试官问的问题不是发散的，而是从点、铺开，比如先聊一聊高并发的话题，就这个话题里面继续聊聊缓存、MQ等等东西。对于每个小话题，比如说MQ，就会从浅入深。

## 1、为什么使用消息队列？

#### 1.剖析

首先明白系统中为什么要用到消息队列这种东西？

因为之前面试的大量候选人，说自己项目中用了Redis，MQ，但是其实他们并不清楚为什么要用这个东西，说白了就是为了用而用，或者是别人设计的架构，从头到尾就没有思考过。

没有对自己架构问过为什么的人，一定是平时没有思考的人，面试官对这种类型的人印象通常不好。

#### 2.解答

其实就是问问你消息队列有哪些场景，然后你项目里面的具体是什么场景，说说你在这个场景里用什么消息队列？

消息队列的场景使用场景很多，主要是有三个：解耦、异步、削峰

#### 3.解耦

**不适用MQ时**

A系统发送数据到B、C、D系统，但没有使用消息队列时候的耦合场景

![image-20220108102740348](https://gitee.com/huangwei0123/image/raw/master/img/image-20220108102740348.png)

当后面系统不断增加，比如 E，F系统的加入，以及D系统的移除

![image-20220108102817698](https://gitee.com/huangwei0123/image/raw/master/img/image-20220108102817698.png)

因为A系统和其它各种系统耦合起来，那么需要处理的事情会很多，而且每添加一个新服务就需要去修改代码。

**使用MQ后**

系统A发送一条消息，到消息队列中，哪个系统需要获取到哪里，直接从MQ中消费数据，如果新系统E加入得话，那么只需要编写代码，然后也直接从MQ中消费即可。

当系统D不需要这个数据时，那么只需要不对该消息进行消费即可。系统A不需要考虑给谁发送数据，也不需要维护这个代码，不需要考虑人家是否调用成功、失败、超时等等情况。

![image-20220108104625134](https://gitee.com/huangwei0123/image/raw/master/img/image-20220108104625134.png)

总结：通过一个MQ，发布/订阅模型（Pub/Sub模型），系统A就和其他系统彻底解耦。

需要考虑一下负责得系统中，是否有类似得场景，就是一个系统或者一个模块，调用了多个系统，互相之间得调用很复杂，维护起来很麻烦。但是其实这个调用是不需要同步调用接口的，如果用MQ给他异步化解耦，也是可以的，这个时候就可以考虑在自己的项目中，是不是可以运用MQ来进行系统的解耦。

#### 4.异步

**不用MQ的同步高延时请求场景**

下面的一个场景就是系统A，调用了其它三个系统的服务，我们发现用户在执行一个请求后，需要花费很长的时间

![image-20220108105229034](https://gitee.com/huangwei0123/image/raw/master/img/image-20220108105229034.png)

我们发现，用户执行一个接口，就需要花费350毫秒，假设我们将每个接口的耗时增加，可能会将近花费1秒，这个时候一般用户几乎不能接受，因为一般互联网类的企业，对用户的直接操作，一般要求是每个请求都必须在200ms以内完成，因为这个是对用户是无感知的

**使用MQ进行异步化**

![image-20220108105635830](https://gitee.com/huangwei0123/image/raw/master/img/image-20220108105635830.png)

系统A只需要发送消息到MQ中就直接返回了，然后其它系统各自在MQ中进行消费。用户在执行系统A的时候，就会感觉非常快就得到响应了。

#### 5.削峰

**没有用MQ的削峰**

![image-20220108110354077](https://gitee.com/huangwei0123/image/raw/master/img/image-20220108110354077.png)

一般Mysql，扛到QPS = 2000的时候就已经达到了瓶颈，如果每秒请求达到了5000的话，可能就把MySQL直接打死了。如果Mysql挂掉，整个系统就直接崩溃，无法使用。

但是中午高峰期过了以后，到下午的时候就出现了低峰期，可能也就一万用户在网站上操作，每秒的请求数量可能就50个请求，对整个系统几乎没有任何压力。

**使用MQ来进行削峰**

![image-20220108110708930](https://gitee.com/huangwei0123/image/raw/master/img/image-20220108110708930.png)

削峰就是大量的请求过来，然后MQ将其消化掉了，然后通过其它系统从MQ中取消息，在逐步进行消费，保证系统的有序运行。一般高峰期不会持续太长，在一段时间后，就会被下游系统消化掉。

## 2、消息队列有什么优点和缺点？

优点上面已经说了：解耦、异步、削峰，缺点呢？显而易见的

- 系统可用性降低：系统引入的外部依赖越多，越容易挂掉，本来你就是A系统调用BCD三个系统接口就好了，人家ABCD四个系统好好的，没啥问题，这个时候把MQ引入进来，万一MQ挂掉，整套系统也就崩了。
- 系统复杂度提高：硬生生加个MQ进来，你怎么保证消息没有重复消费？怎么处理消息丢失的情况？怎么保证消息传递的顺序性？
- 一致性问题：A系统处理完了直接返回成功，人都以为你的请求成功了，但是问题是，在BCD三个系统中，BD两个系统写库成功了，C系统写库失败了，这也会存在数据不一致的问题。
- 所以说消息队列实际上是一种**复杂的架构**，你引入它有好多好处，但是也得针对它带来的坏处做各种额外的技术方案和架构来规避掉，最后发现系统复杂性提升了一个数量级，也许是复杂10倍，**但是关键时刻，用还是得用。**

![image-20220108111854389](https://gitee.com/huangwei0123/image/raw/master/img/image-20220108111854389.png)

## 3、MQ有什么区别，以及适用场景

主流MQ包括：kafka、ActiveMQ、RabbitMQ和RocketMQ

常见的MQ其实就上面的四种

| 特性       | ActiveMQ                                                     | RabbitMQ                                                     | RocketMQ                                                     | Kafka                                                        |
| ---------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 单机吞吐量 | 万级，吞吐量比RocketMQ和Kafka要低一个数量级                  | 万级，吞吐量比RocketMQ和Kafka要低一个数量级                  | 10万级，RocketMQ也是可以支撑高吞吐的一种MQ                   | 10万级1这是kafka最大的优点，就是吞吐量高。一般配置和数据类的系统进行实时数据计算、日志采集等场景 |
| 时效性     | ms级                                                         | 微妙级，这是RabbitMQ的一大特点，就是延迟最低                 | ms级                                                         | 延迟在ms级内                                                 |
| 可用性     | 基于主从架构实现高可用                                       | 高，基于主从架构实现高可用                                   | 非常高，分布式架构                                           | 非常高，kafka是分布式的，一个数据多个副本，少数机器宕机后，不会丢失数据，不会导致不可用 |
| 消息可靠性 | 有较低的概率丢失数据                                         | 消息不丢失                                                   | 经过参数优化配置，可以做到0丢失                              | 经过参数优化配置可以做到0丢失                                |
| 核心特点   | MQ领域的功能及其完备                                         | 基于Erlang开发，所以并发能力强，性能及其好，延时很低         | MQ功能较为完善，还是分布式的，扩展性好                       | 功能较为简单，主要支持简单的MQ功能，在大数据领域的实时计算以及日志采集被大规模使用，是实时上的标准。 |
|            | 非常成熟，功能强大，在业内大量公司以及项目都有应用。  但是偶尔消息丢失的概率，并且现在社区以及国内应用都越来越少，官方社区对ActiveMQ5.X维护越来越少，而且确实主要是基于解耦和异步来用的，较少在大规模吞吐场景中使用 | erlang语言开发的，性能及其好，延时很低。而且开源的版本，就提供的管理界面非常棒，在国内一些互联网公司近几年用RabbitMQ也是比较多一些，特别适用于中小型的公司 缺点显而易见，就是吞吐量会低一些，这是因为它做的实现机制比较中，因为使用erlang开发，目前没有多少公司使用其开发。所以针对源码界别的定制，非常困难，因此公司的掌控非常弱，只能依赖于开源社区的维护。 | 接口简单易用，毕竟在阿里大规模应用过，有阿里平台保障，日处理消息上 百亿之多，可以做到大规模吞吐，性能也非常好，分布式扩展也很方便，社区维护还可以，可靠性和可用性都是OK的，还可以支撑大规模的topic数量，支持复杂MQ业务场景。 | 仅仅提供较少的核心功能，但是提供超高的吞吐量，ms级别的延迟，极高的可用性以及可靠性，分布式可以任意扩展。    同时kafka最好是支撑较少的topic数量即可，保证其超高的吞吐量。 |

综上所述：

- 一般业务要引入MQ，最早大家都用ActiveMQ，但是现在用的不多，没有经过大规模吞吐量场景的验证，社区也不是很活跃，不推荐使用
- RabbitMQ后面被大量的中小公司使用，但是erlang语言阻碍了大量的Java工程师深入研究和掌握它，对公司而言，几乎处于不可控的状态，但是RabbitMQ目前开源稳定，活跃度也表较高。
- RocketMQ是阿里开源的一套消息中间件，目前也已经经历了天猫双十一，同时底层使用Java进行开发

如果中小型企业技术实力一般，技术挑战不是很高，可以推荐，RabbitMQ。如果公司的基础研发能力很强，想精确到源码级别的掌握，那么推荐使用RocketMQ。

- 同时如果项目是聚焦于大数据领域的**实时计算，日志采集**等场景，那么Kafka是业内标准。

## 4、如何保证消息队列的高可用？

#### 1.剖析

这个问题问的很好，不会具体到哪个MQ，而是问一个整体，然后通过你使用的MQ,来谈谈你对该MQ可用性的理解

#### 2.RabbitMQ高可用

RabbitMQ是比较有代表性的，因为是基于主从做高可用性的。

RabbitMQ 三种模式：单机模式，普通集群模式，镜像集群模式

**单机模式**

就是demo级别的，一般就是本地启动后玩一玩，没有人生产环境中使用。

**普通集群模式**

- 意思就是在多台机器上启动多个RabbitMQ实例，每台机器启动一个，但是创建的Queue，只会放在一个RabbitMQ实例上，但是每个实例都同步queue的元数据，在消费的时候，实际上是连接到另外一个实例上，那么这个实例会从queue所在实例上拉取数据过来，**这种方式确实很麻烦，也不怎么好，没做到所谓的分布式，就是个普通集群**。因为这导致你要么消费每次随机连接一个实例，然后拉取数据，要么固定连接哪个queue所在实例消费数据，**前者有数据拉取的开销，后者导致单实例性能瓶颈。**
- 而且如果那个放queue的实例宕机了，会导致接下来其他实例无法从那个实例继续拉取，如果你开启了消息持久化，让rabbitmq落地存储消息的话，消息不一定会丢，等到这个实例恢复了，然后才可以继续从这个queue拉取数据。

![image-20220108142251906](https://gitee.com/huangwei0123/image/raw/master/img/image-20220108142251906.png)

​	

**集群镜像模式**

这种模式，才是RabbitMQ的高可用模式，==和普通的集群模式不一样的是，你创建的queue无论元数据还是queue里的消息都会存在与多个实例中，然后每次你写消息到queue的时候，都会自动把消息推到多个实例的queue中进行消息同步==。

这样的好处在于，你任何一个机器宕机了，别的机器都可用。坏处在于，性能开销提升，消息同步所有的机器，导致网络带宽压力和消耗增加。第二，就是没有什么扩展性科研，如果某个queue负载很重，你加机器，新增的机器也包含了这个queue的所有数据，并没有办法线性扩展你的queue。

那么如何开启**集群镜像策略**呢？就是在Rabbitmq管理后台，新增一个策略，这个策略就是镜像集群模式下的策略，指定的时候，可以要求数据同步到所有节点，也可以就要求 同步到指定数量的节点，然后再次创建queue的时候，应用这个策略，就会自动将数据同步到其他节点上去了。

![image-20220108143713766](https://gitee.com/huangwei0123/image/raw/master/img/image-20220108143713766.png)

集群镜像模式下，任何一个节点宕机了都是没问题的，因为其他节点还包含了这个queue的完整的数据，别的consumer可用到其他活着的节点上消费数据。

但是这个模式还存在问题：就是不是分布式的，如果这个queue的数据量很大，大到这个机器上的容量无法容纳的时候，此时应该怎么办？



#### 3.RocketMQ高可用

根据Broker集群中各个节点间关系的不同，Broker集群可以分为一下几类：

**单Master**

只有一个broker（其本质不能叫集群），这种方式也只能在测试时使用，生产环境下不能使用，因为存在单点问题。

**多Master**

broker集群仅由多个master构成，不存在slave。同一个Topic的各个Queue会平均分布在各个master节点上。

- 优点：配置简单，单个master宕机或重启维护对应用无影响，在磁盘配置为RAID10时，即使机器宕机不可恢复的情况下，由于RAID10磁盘非常可靠，消息也不会丢（异步刷盘丢失少量消息，同步刷盘一条不丢）性能最高
- 缺点：单台机器宕机期间，这台机器上未被消费的消息在机器恢复之前不可订阅（不可消费），消息实时性会受到影响。

> 以上优点的前提是，这些Master都配置了RAID磁盘阵列，如果没有配置，一旦出现某Master宕机，则会发送大量消息丢失的情况

**多Master多Slave模式-异步复制**

broker集群由多个master构成，每个master又配置多哥slave（在配置了RAID磁盘阵列的情况下，一个master一般配置一个slave即可）。master与slave的关系是**主备关系**，**即master负责处理消息的读写请求，而slave仅负责消息的备份与master宕机后的角色切换**。

**异步复制**即前面讲的 `复制策略`中的 `异步复制策略`,即消息写入master成功后，master立即向producer返回成功ACK，无需等待slave同步数据成功。

该模式的最大特点之一是，当master宕机后slave能够 `自动切换` 为master。不过由于slave从master的同步具有短暂的延迟（毫秒级），所以**当master宕机后，这种异步复制方式可能会存在少量消息的丢失问题。**

> slave 从master同步的延迟越短，其可能丢失的消息就越少
>
> 对于master的RAID磁盘阵列，若使用的也是异步复制策略，同样也存在延迟问题，同样也可能会丢失消息。但RAID阵列的秘诀是微秒级的（因为是由硬盘支持的），所以其丢失的数据量也会更少。

**多Master多Slave模式-同步双写**

该模式是`多Master多Slave模式`的`同步复制`实现。所谓`同步双写`,指的是消息写入master成功后，master会等待slave同步数据成功后才向producer返回成功ACK，即master与slave都要写入成功后才会返回成功ACK,也即`双写`

该模式与`异步复制模式`相比，优点事消息的安全性更高，不存在消息丢失的情况，但是单个消息的RT略高，从而导致性能要略低（**大约低10%**）

该模式存在一个大的问题：对于目前版本，master宕机后，slave`不会自动切换`到master

**最佳实践**

**一般会为Master配置RAID10磁盘阵列，然后再为其配置一个Slave，即利用了RAID10磁盘阵列的高效、安全性、又解决了可能会影响订阅的问题。**

> 1、RAID磁盘阵列的效率要高于Master-Slave集群，因为RAID是硬件支持的。也是正因为如此，所以搭建RAID的成本较高。
>
> 2、多Master+RAID阵列，与多Master多Slave集群的区别是什么？
>
> - 多master+RAID阵列，其仅仅可以保证数据不丢失，即不影响消息写入，但其可能会影响到消息的订阅。但其执行效率要远高于`多master多slave集群`
> - 多master多slave集群，其不仅可以保证数据不丢失，也不会影响消息写入。其运行效率要低于`多master+RAID阵列`



#### 4.Kafka高可用

![image-20220108150318567](https://gitee.com/huangwei0123/image/raw/master/img/image-20220108150318567.png)

kafka一个最基本的架构认识：多个broker组件，每个broker是一个节点，你创建一个topic，这个topic可以划分成多个partition，每个partition可以存在于不同的broker上，每个partition就放一部分数据。

这就是天然的分布式消息队列，就是说一个topic的数据，是分散在多个机器上的，每个机器上就放一部分数据。

实际上RabbitMQ之类的，并不是分布式消息队列，他就是传统的消息队列，只不过提供了一些集群、HA的机制而已，因为无论怎么玩，RabbitMQ一个queue的数据都放在一个节点里了，镜像集群下，也是每个节点都放这个queu的完整数据

> kafka0.8以前，是没有HA机制的，就是任何一个broker宕机了，那个broker上的partition就废了，没法读也没办法写，没有什么高可用可言。
>
> 而在0.8版本后，提供了HA机制，就是replica副本机制，每个partition的数据都会同步到其它机器上，形成自己的多个replica副本，然后所有的replica就是follower，写的时候，leader会负责数据都同步到所有的follower上，读的时候就直接读取leader上的数据即可。只能读写leader？很简单，要是你能随意读写每个follower，那么就需要保证数据一致性的问题，系统复杂度太高，很容易出问题，kafka会均匀的将一个partition的所有replica分布在不同的机器上，这样才能够提高容错性

每个副本不会存储节点的全部数据，而是数据可能分布在不同的机器上。

![image-20220108150941963](https://gitee.com/huangwei0123/image/raw/master/img/image-20220108150941963.png)

==同时多个副本中，会选取一个作为leader，其它的副本是作为follower，并且只有leader能对外提供读写，同时leader在写入数据后，它还会把全部的数据同步到follower中，保证数据的备份==。

此时，**高可用的架构就出来了**，假设现在某个机器宕机了，比如其中的一个leader宕机了，但是因为每个leader下还有多个follower，并且每个follower都进行了数据的备份，因此kafka会自动感知leader已经宕机，同时将其它的follower给选举出来，作为新的leader，并向外提供服务支持。



## 5、如果保证消息的重复消费？

面试题：如何保证消息的重复消费？如何保证消息消费的幂等性？

#### 1.剖析

其实这是一个常见的问题，既然是消费消息，那肯定是要考虑**会不会重复消费**？**能不能避免重复消费**？或者重复消费了也别造成系统异常可以吗？关于消息重复消费的问题，==其实本质上就是问你使用消息队列如何保证幂等性==（**因为消息队列是不能保证不重复消费的**），这个是你架构中要考虑的问题。

首先要确认的一点就是，RabbitMQ、RocketMQ、Kakfa都会出现消息重复消费的问题，因为这个问题通常不是MQ自己保证的，而是保证消息的不丢失，我们首先从kafka上来说：

kafka实际上有个offset（偏移量）的概念，每写一个消息进去，都有一个offset，代表消息的序号，然后consumer消费了数据之后，每隔一段时间，会把自己消费过的消息的offset提交一下，代表已经消费过了。下次要是重启或者挂掉了，就从上次消费到的offset的位置来继续消费。

但是凡事总有以外，比如生产经常遇到的特殊情况：

> 就是在重启系统的时候，如果不正常重启，直接kill 杀死进程，然后重启，这就会导致consumer有些消息处理了没来得及提交offset，然后重启后，就会造成少数消息重复消费的问题呢。

**RocketMQ消息重复消费的场景分析**

**发送时消息重复**

当一条消息已经被成功发送到Broker并**完成持久化**，此时出现了**网络闪断**，从而导致Broker对**Producer应答失败**。如果此时Producer意识到**消息发送失败并尝试再次发送消息**，此时Broker中可能会出现**两条内容相同并且Message ID也相同的消息**，**那么后续Consumer就一定会消费两次该消息。**

**消费时消息重复**

消息已投递到Consumer并完成业务处理，当Consumer给Broker反馈应答时网络闪断，**Broker没有接收到消费成功响应**。为了保证消息`至少被消费一次`的原则，Broker将在网络恢复后**再次尝试投递之前已被处理过的消息**。**此时消费者就会收到与之前处理过的内容相同、Message ID也相同的消息。**

**Rebalance时消息重复**

**当Consumer Group中的Consumer数量发生变化时**，**或其订阅的Topic的Queue数量发生变化时**，**会触发Rebalance**，此时Consumer可能会收到曾经被消费过的消息。

==重复消费其实并不可怕，重要的是有没有考虑过重复消费后，怎么保证幂等性。==

例如：有个系统，消费一条数据往数据库里插入了一条数据，要是消息重复消费了两次，那么久会插入两条数据，这个数据也就出错了。

![image-20220110163847879](https://gitee.com/huangwei0123/image/raw/master/img/image-20220110163847879.png)

消费者如果在准备提交offset，但是还没有提交上去的时候，消费者进程被重启，那么此时传过来的数据的offset并没有被提交，kafka不知道你已经消费了，那么消费者再次上线消费的时候，会把已经消费的数据，再重新传递过来，这时候就出现了消息的重复消费。

#### 2.幂等性是什么？

==若某操作执行多次与执行一次对系统产生的影响时相同的，则该操作是幂等的。==

#### 3.怎么保证消息队列消费的幂等性？

一条数据重复出现两次，但是数据库里只有一条数据，这就保证了系统的幂等性。

#### 4.解决思路

- 比如那个数据要写库，首先根据主键查一下，如果这个数据已经有了，那就别插入了，执行update或者直接返回即可
- 如果用的是redis，那就没问题了，因为每次都是set操作，天然的幂等性
- 如果不是上面的两个场景，那就做的稍微复杂一点，需要让生产者发送每条消息的时候，需要加一个**全局唯一的id**，类似于订单id之后的东西，然后你这里消费到了之后，先根据这个id去redis中查找，之前消费过了么，如果没有消费过，那就进行处理，然后把这个id写入到redis中，**如果消费过了，那就别处理了，保证别重复消费相同的消息即可**。
- 还有比如基于**数据库唯一键来保证重复数据不会重复插入多条**，我们之前线上系统就有这个问题，就是拿到数据的时候，每次重启可能会重复，**因为Kafka消费者还没来得及提交offset**，重复数据拿到了以后，我们进行插入的时候，因为有了唯一键约束了，所以重复数据只会插入报错，不会导致数据库中出现**脏数据**。

![image-20220110173100292](https://gitee.com/huangwei0123/image/raw/master/img/image-20220110173100292.png)

## 6、如何保证消息传输不丢失？

面试题：如何保证消息的可靠性传输（如何处理消息丢失的问题）？

#### 1.剖析

消息队列有3个重要原则：消息不能多，不能少

不能多指的是重复消费和幂等性问题；

不能少指的是在数据传输过程中，不会丢失。

如果说使用MQ用来传递非常核心的消息，比如说计费，扣费的一些消息，比如设计和研发一套核心的广告平台，计费系统是一个很看重的业务，操作时很耗时的，所以说广告系统的核心架构里面，实际是将计费做成异步化的，然后中间加了个一个MQ。例如在广告中投放了一个广告，约定的用户每点击一次就扣费一次，结果是用户动不动就点击了一次，扣费的时候消息搞丢了，公司就会不断得少几块钱。这样积少成多，这就是造成了公司的巨大损失。

#### 2.为什么会丢数据？

丢数据，一般分为2种，要么是MQ自己弄丢了，要么是我们消费得时候弄丢了，我们可从RabbitMQ和Kafka分别来分析。RabbitMQ一般来说都是承载公司得核心业务的，数据是绝对不能弄丢的。

![image-20220110180235272](https://gitee.com/huangwei0123/image/raw/master/img/image-20220110180235272.png)

> **生产者弄丢了数据**

生产者将数据发送到RabbitMQ的时候，可能就在 半路 给搞丢了，因为网络啥的问题，都有可能会发生。

此时选择用RabbitMQ提供的事务功能，就是生产者发生数据之前，开启RabbitMQ（channel.txSelect），然后发送消息，此时就可用回滚事务（channel.exRollback），然后重试发送消息，如果收到了消息，那么可用提交事务，但是问题是，RabbitMQ事务机制一搞，基本吞吐量会下来，因为太损耗性能了。

![image-20220111233945697](https://gitee.com/huangwei0123/image/raw/master/img/image-20220111233945697.png)

所以一般来说，如果你要确保写RabbitMQ消息别丢，可用开启confirm模式，在生产者那里设置了开启confirm模式以后，RabbitMQ会给你回传一个ack消息，告诉你这个消息ok了，如果RabbitMQ没能接收到这个消息，会给你一个回调接口，告诉你这个消息接收失败，你可用重试。

```java
// 开启事务
try {
 // 发送消息
} catch(Exception e) {
 // 重试发送消息
}
//  提交
```

但是，因为事务机制，是同步的

针对上述事务造成性能下降的问题，下面的方法是开启confirm模式

- 首先把channel设置成confirm模式
- 然后发送一个消息
- 发送完之后，就不用管了
- RabbitMQ如果接收到这个消息的话，就会回调你生产者本地的一个接口，通知你说这条消息我们已经收到了
- RabbitMQ如果在接收消息的时候出错了，就会回调这个接口

==一般保证生成者消息不丢失，会采用confirm机制==

因为这个是异步模式，发送消息后，不会阻塞队列，直接可用发送下一条消息，这样吞吐量会更高。

> **RabbitMQ丢数据**

这个就是RabbitMQ自己丢失数据，这个时候就必须==开启RabbitMQ的持久化==，将消息写入后，同时需要持久化到磁盘中，哪怕是RabbitMQ自己宕机了，也能从磁盘中读取之前存储的消息。**这样一般消息就不会丢失了。**

但是存在一个极其极端的情况，**就是RabbitMQ还没持久化的时候，就已经宕机了，那么可能会造成少量的数据丢失，但是这个概率是比较小的。**

设置持久化的两个步骤：

1、创建queue的时候，将其持久化。这样就保证了RabbitMQ持久化queue的元数据，但是不会持久化queue中数据

2、发送消息的是，将消息的deliveryMode设置为2，就是将消息设置为持久化的，此时RabbitMQ将会把消息持久化到磁盘上，==必须同时设置两个持久化才行==，哪怕是RabbitMQ挂了，也会从磁盘中恢复queue元数据和queue中的数据。

而且持久化可用跟生产者那边的confirm机制配置起来，只有消息被持久化到磁盘后，才会通知生产者ACK了，所以哪怕是在持久化磁盘之前，RabbitMQ挂了，数据丢了，生产者收不到返回的ACK，也是可用触发重试接口（重发）的。

> **消费者丢失数据**

