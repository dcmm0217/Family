# 并发编程深度知识点汇总

#### 1、线程和进程的区别

进程是代码在数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，线程则是进程的一个执行路径，==一个进程中至少有一个进程，进程中的多个线程共享进程的资源。==

操作系统在分配资源时是把资源分配给进程的，但是CPU资源比较特殊，它是被分配到线程的，因为真正要占用CPU运行的是线程，所以说线程是CPU分配的基本单位。

在Java中，当我们启动main函数时其实就是启动了一个JVM进程，而main函数所在的线程就是这个进程中的一个线程，也称为主线程。

==一个进程中有多个线程，多个线程共享进程的堆和方法区资源，但是每个线程都有自己的程序计数器和栈区域。==

![image-20220412093019496](https://mygiteepic.oss-cn-shenzhen.aliyuncs.com/img/image-20220412093019496.png)

#### 2、为何要将程序计数器设置为线程私有区域

程序计数器是一块内存区域，用来记录线程当前要执行的指令地址。线程是占用CPU时间片的基本单位，而CPU一般是使用时间片轮转方式让多线程轮询占用的，所以当前线程CPU时间片用完后，要让出CPU，等下次轮到自己的时候再执行。==那么如何知道之前程序执行到哪里了呢？==

==其实程序计数器就是为了记录该线程让出CPU时的执行地址的，待再次分配到时间片时线程就可以从自己私有的计数器指定地址继续执行==。另外需要注意的是，如果执行的是native方法，那么pc计数器记录的是undefined地址，只有执行的是java代码时，pc计数器记录的才是下一条指令的地址。

#### 3、局部变量，对象实例，JVM加载的类，常量及静态变量都存放在内存的哪部分，是线程私有的吗？

- 每个线程都有自己的栈资源，用于存储该线程的局部变量，这些局部变量是该线程私有的，其他线程是访问不了的，除此之外栈还用来存放线程的调用栈帧。
- 堆是一个进程中最大的一块内存，堆是被进程中的所有线程共享的，是进程创建时分配的，堆里面主要存放使用new 操作创建的对象实例。
- 方法区则是用来存放JVM加载的类、常量、静态变量等信息，也是线程共享的。

#### 4、集成Thread类实现多线程的优劣

使用继承方式的好处是，在run()方法内获取当前线程直接使用this就可以了，无须使用Thread.currentThread()方法；

不好的地方是Java不支持多继承，如果继承了Thread类，那么就不能再继续继承其他类。

另外任务与代码没有分离，当多个线程执行一样的任务时需要写多份任务代码，Runnable接口则没有这个限制。

![image-20220412095449111](https://mygiteepic.oss-cn-shenzhen.aliyuncs.com/img/image-20220412095449111.png)

#### 5、IlleagalMonitorStateException出现原因

==总结：如果没有获取对象的监视器锁，去操作对象的等待/唤醒状态的时候会出现非发监视器状态异常==

```java
Lock lock = new ReentrantLock();
// lock.lock();
try {
} catch (Exception e) {
    e.printStackTrace();
} finally {
    lock.unlock();
}

Object o = new Object();
o.wait();
```

#### 6、一个线程如何才能去获取一个共享变量的监视器锁呢？

（1）执行synchronized同步代码块时，使用共享变量作为参数。

```java
synchronized(共享变量){
    //doing
}
```

（2）调用该共享变量的方法，并且该方法使用了synchronized修饰。

```java
synchronized void add(int a,int b){
    //doing
}
```

（3）使用lock锁

```java
Lock lock = new ReetrantLock();
lock.lock();
```

#### 7、什么时虚假唤醒，如何避免虚假唤醒？

==在一个线程没有被其他线程调用notify()、notifyAll()方法进行通知，或者被中断，或者等待超时，这个线程仍然可以挂起状态变为可运行状态（也就是被唤醒），这就是所谓的虚假唤醒。==

虽然虚假唤醒在应用实践中很少发生，但是要防患于未然，做法就是不停地去测试该线程被唤醒地条件是否满足，不满足则继续等待，也就是说一个while循环中调用wait()方法进行防范。退出循环地条件是满足了唤醒该线程的条件。

```java
synchronized(obj){
    while(条件不满足){
        obj.wait();
    }
}
```

while在这里是防止虚假唤醒的关键，试想下，一旦发生虚假唤醒，线程会根据while添加再次进行判断，一旦条件不满足，会立即再次将线程挂起。

#### 8、调用共享对象的notify()方法后，会唤醒一个在该共享变量上调用wait的线程，说说两个线程对锁的获取释放过程？

一个线程调用共享对象的nofity()方法后，会唤醒一个在该共享变量上调用wait系列方法后被挂起的线程。

此外，被唤醒的线程不能马上从wait方法返回并继续执行，它必须在获取了共享对象的监视器锁后才可以返回（调用wait后，会释放当前共享对象的锁，如果不释放会造成死锁。）也就是唤醒它的线程释放了共享变量上的监视器锁后，被唤醒的线程也不一定会立即获取到共享对象的监视器锁，这是因为该线程还需要和其他线程一起竞争该锁，==只有该线程竞争到了共享变量的监视器锁后才可以继续执行==。

类似wait系列方法，只有当前线程获取到了共享变量的监视器锁后，才可以调用共享变量的notify()方法，否则会抛出`IlleagalMonitorStateException`异常。

#### 9、说说线程中的join方法和yeild方法

在项目实践中经常会遇到一个场景，就是需要等待某几件事情完成后才能继续往下执行。

比如：多个线程加载资源，需要等待多个线程全部加载完毕再做汇总处理。Thread类中有一个join方法就是可以做这个事情，join方法是Thread类直接提供的。join是无参且返回值为void的方法。

Thread类中有一个静态的yield方法，当一个线程调用yield方法时，实际上就是暗示线程调度器当前线程请求让出自己的CPU使用。我们知道操作系统是为每个线程分配一个时间片来占有CPU的，正常情况下当一个线程把分配给自己的时间片使用完后，线程调度器才会进行下一轮的线程调度；

而当一个线程调用了Thread类的静态方法yield时，是在告诉线程调度器自己占有的时间片还没有使用完的部分自己不想用了，这暗示线程调度器现在就可以进行下一轮的线程调度。

当一个线程调用yield方法时，当前线程会让出CPU使用权，然后处于就绪状态，线程调度器从线程就绪队列里面获取一个线程优先级最高的线程，当然也有可能会调度到刚刚让出CPU的那个线程来获取CPU执行权。

#### 10、说说sleep方法和yield方法的区别

sleep与yield方法的区别在于，当线程调用sleep方法时线程会被阻塞挂起指定实践，在这期间线程调度器不会去调度该线程。

而调用yield方法时，线程只是让出了自己的剩余时间片，并没有被阻塞挂起，而是处于就绪状态，线程调度器下一次调度时就有可能调度到当前线程执行。

