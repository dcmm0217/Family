# 并发编程深度知识点汇总

#### 1、线程和进程的区别

进程是代码在数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，线程则是进程的一个执行路径，==一个进程中至少有一个进程，进程中的多个线程共享进程的资源。==

操作系统在分配资源时是把资源分配给进程的，但是CPU资源比较特殊，它是被分配到线程的，因为真正要占用CPU运行的是线程，所以说线程是CPU分配的基本单位。

在Java中，当我们启动main函数时其实就是启动了一个JVM进程，而main函数所在的线程就是这个进程中的一个线程，也称为主线程。

==一个进程中有多个线程，多个线程共享进程的堆和方法区资源，但是每个线程都有自己的程序计数器和栈区域。==

![image-20220412093019496](https://mygiteepic.oss-cn-shenzhen.aliyuncs.com/img/image-20220412093019496.png)

#### 2、为何要将程序计数器设置为线程私有区域

程序计数器是一块内存区域，用来记录线程当前要执行的指令地址。线程是占用CPU时间片的基本单位，而CPU一般是使用时间片轮转方式让多线程轮询占用的，所以当前线程CPU时间片用完后，要让出CPU，等下次轮到自己的时候再执行。==那么如何知道之前程序执行到哪里了呢？==

==其实程序计数器就是为了记录该线程让出CPU时的执行地址的，待再次分配到时间片时线程就可以从自己私有的计数器指定地址继续执行==。另外需要注意的是，如果执行的是native方法，那么pc计数器记录的是undefined地址，只有执行的是java代码时，pc计数器记录的才是下一条指令的地址。

#### 3、局部变量，对象实例，JVM加载的类，常量及静态变量都存放在内存的哪部分，是线程私有的吗？

- 每个线程都有自己的栈资源，用于存储该线程的局部变量，这些局部变量是该线程私有的，其他线程是访问不了的，除此之外栈还用来存放线程的调用栈帧。
- 堆是一个进程中最大的一块内存，堆是被进程中的所有线程共享的，是进程创建时分配的，堆里面主要存放使用new 操作创建的对象实例。
- 方法区则是用来存放JVM加载的类、常量、静态变量等信息，也是线程共享的。

#### 4、集成Thread类实现多线程的优劣

使用继承方式的好处是，在run()方法内获取当前线程直接使用this就可以了，无须使用Thread.currentThread()方法；

不好的地方是Java不支持多继承，如果继承了Thread类，那么就不能再继续继承其他类。

另外任务与代码没有分离，当多个线程执行一样的任务时需要写多份任务代码，Runnable接口则没有这个限制。

![image-20220412095449111](https://mygiteepic.oss-cn-shenzhen.aliyuncs.com/img/image-20220412095449111.png)

#### 5、IlleagalMonitorStateException出现原因

==总结：如果没有获取对象的监视器锁，去操作对象的等待/唤醒状态的时候会出现非发监视器状态异常==

```java
Lock lock = new ReentrantLock();
// lock.lock();
try {
} catch (Exception e) {
    e.printStackTrace();
} finally {
    lock.unlock();
}

Object o = new Object();
o.wait();
```

#### 6、一个线程如何才能去获取一个共享变量的监视器锁呢？

（1）执行synchronized同步代码块时，使用共享变量作为参数。

```java
synchronized(共享变量){
    //doing
}
```

（2）调用该共享变量的方法，并且该方法使用了synchronized修饰。

```java
synchronized void add(int a,int b){
    //doing
}
```

（3）使用lock锁

```java
Lock lock = new ReetrantLock();
lock.lock();
```

#### 7、什么时虚假唤醒，如何避免虚假唤醒？

==在一个线程没有被其他线程调用notify()、notifyAll()方法进行通知，或者被中断，或者等待超时，这个线程仍然可以挂起状态变为可运行状态（也就是被唤醒），这就是所谓的虚假唤醒。==

虽然虚假唤醒在应用实践中很少发生，但是要防患于未然，做法就是不停地去测试该线程被唤醒地条件是否满足，不满足则继续等待，也就是说一个while循环中调用wait()方法进行防范。退出循环地条件是满足了唤醒该线程的条件。

```java
synchronized(obj){
    while(条件不满足){
        obj.wait();
    }
}
```

while在这里是防止虚假唤醒的关键，试想下，一旦发生虚假唤醒，线程会根据while添加再次进行判断，一旦条件不满足，会立即再次将线程挂起。

#### 8、调用共享对象的notify()方法后，会唤醒一个在该共享变量上调用wait的线程，说说两个线程对锁的获取释放过程？

一个线程调用共享对象的nofity()方法后，会唤醒一个在该共享变量上调用wait系列方法后被挂起的线程。

此外，被唤醒的线程不能马上从wait方法返回并继续执行，它必须在获取了共享对象的监视器锁后才可以返回（调用wait后，会释放当前共享对象的锁，如果不释放会造成死锁。）也就是唤醒它的线程释放了共享变量上的监视器锁后，被唤醒的线程也不一定会立即获取到共享对象的监视器锁，这是因为该线程还需要和其他线程一起竞争该锁，==只有该线程竞争到了共享变量的监视器锁后才可以继续执行==。

类似wait系列方法，只有当前线程获取到了共享变量的监视器锁后，才可以调用共享变量的notify()方法，否则会抛出`IlleagalMonitorStateException`异常。

#### 9、说说线程中的join方法和yeild方法

在项目实践中经常会遇到一个场景，就是需要等待某几件事情完成后才能继续往下执行。

比如：多个线程加载资源，需要等待多个线程全部加载完毕再做汇总处理。Thread类中有一个join方法就是可以做这个事情，join方法是Thread类直接提供的。join是无参且返回值为void的方法。

Thread类中有一个静态的yield方法，当一个线程调用yield方法时，实际上就是暗示线程调度器当前线程请求让出自己的CPU使用。我们知道操作系统是为每个线程分配一个时间片来占有CPU的，正常情况下当一个线程把分配给自己的时间片使用完后，线程调度器才会进行下一轮的线程调度；

而当一个线程调用了Thread类的静态方法yield时，是在告诉线程调度器自己占有的时间片还没有使用完的部分自己不想用了，这暗示线程调度器现在就可以进行下一轮的线程调度。

当一个线程调用yield方法时，当前线程会让出CPU使用权，然后处于就绪状态，线程调度器从线程就绪队列里面获取一个线程优先级最高的线程，当然也有可能会调度到刚刚让出CPU的那个线程来获取CPU执行权。

#### 10、说说sleep方法和yield方法的区别

sleep与yield方法的区别在于，当线程调用sleep方法时线程会被阻塞挂起指定实践，在这期间线程调度器不会去调度该线程。

而调用yield方法时，线程只是让出了自己的剩余时间片，并没有被阻塞挂起，而是处于就绪状态，线程调度器下一次调度时就有可能调度到当前线程执行。

#### 11、说说interrupt(),isInterrupted()和interrupted()的特点和区别

- `void interrupt()方法`：中断线程，例如，当线程A运行时，线程B可以调用线程A的interrupt()方法来设置线程A的中断标志为true并立即返回。设置标志仅仅是设置标志，线程A实际并没有被中断，它会继续往下执行。如果线程A因为调用了wait系列函数、join方法或者sleep方法而被阻塞挂起，这时候若线程B调用线程A的interrupt()方法，线程A会在调用这些方法的地方抛出InterruptedException异常而返回。

- `boolean isInterrupted()方法：`检测当前线程是否被中断，如果是返回true，否则返回false

- `static boolean interrupted()方法：`检测当前线程是否被中断，如果是返回true，否则返回false。与IsInterrupt()不同的是，该方法如果发现当前线程被中断，则会清除中断标志，并且该方法是static方法，可以通过Thread类直接调用。

  另外下面的代码可以知道，在`static interrupt()`内部是获取当前调用线程的中断标志而不是调用`static interrupted()`方法的实例对象的中断标志。

![image-20220412180014320](https://mygiteepic.oss-cn-shenzhen.aliyuncs.com/img/image-20220412180014320.png)

#### 12、什么是死锁

死锁是指两个或两个以上的线程在执行过程中，因争夺资源而造成的互相等待的现象，在无外力作用的情况下，这些线程会一直相互等待而无法继续运行下去。

![image-20220413092911278](https://mygiteepic.oss-cn-shenzhen.aliyuncs.com/img/image-20220413092911278.png)

如上图例子：线程A已经持有了资源2，它同时还想申请资源1，线程B已经持有了资源1，它同时还想申请资源2，所以线程1和线程2就因为相互等待对方已经持有的资源，而进入了死锁状态。

#### 13、为什么会出现线程死锁并写出死锁的示例代码

死锁的产生必须具备以下四个条件：

- 互斥条件：指线程对已经获取到的资源进行排它性使用，即该资源同时只由一个线程占用。如果此时还有其他线程请求获取该资源，则请求者只能等待，直至占有资源的线程释放该资源。
- 请求并持有条件：指一个线程已经持有了至少一个资源，但又提出了新得资源请求，而新资源已经被其他线程占有，所以当前线程会被阻塞，但阻塞得同时并不释放自己已经获取得资源。
- 不可剥夺条件：指线程获取到得资源在自己使用完之前不能被其他线程抢占，只有在自己使用完毕后才能由自己释放该资源。
- 环路等待条件：指在发生死锁时，==必然存在一个线程-->资源得环形链==，即线程集合{T0，T1，T2,....，Tn}中得T0正在等待一个T1占用的资源，T1正在等待T2占用的资源，.....Tn正在等待已被T0占用的资源。

```java
public class DeadLockDemo{
    public static void main(String[] args){
        final Object objectLockA = new Object();
        final Object objectLockB = new Object();

        new Thread(() -> {
            synchronized (objectLockA)
            {
                System.out.println(Thread.currentThread().getName()+"\t"+"自己持有A，希望获得B");
                //暂停几秒钟线程
                try { TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); }
                synchronized (objectLockB)
                {
                    System.out.println(Thread.currentThread().getName()+"\t"+"A-------已经获得B");
                }
            }
        },"A").start();

        new Thread(() -> {
            synchronized (objectLockB)
            {
                System.out.println(Thread.currentThread().getName()+"\t"+"自己持有B，希望获得A");
                //暂停几秒钟线程
                try { TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); }
                synchronized (objectLockA)
                {
                    System.out.println(Thread.currentThread().getName()+"\t"+"B-------已经获得A");
                }
            }
        },"B").start();

    }
}
```

#### 14、如何避免死锁

要想避免死锁，只需要破坏掉至少一个构成死锁的必要条件即可，目前只有请求并持有和环路等待条件是可以被破坏的。

破坏请求并持有条件：调整资源的访问顺序，让访问有序进行。

破坏环路等待条件：调整资源的访问顺序，让访问有序进行。

如上题代码让在线程B中获取资源的顺序和在线程A中获取资源的顺序保持一致，其实资源分配有序性就是指，假如线程A和线程B都需要资源1，2，3，.....，n时，对资源进行排序，线程A和线程B只有在获取了资源n-1时才能去获取资源n。

![image-20220413101154609](https://mygiteepic.oss-cn-shenzhen.aliyuncs.com/img/image-20220413101154609.png)

#### 15、简单说说你对ThreadLocal的了解

ThreadLocal是JDK包提供的，它提供了线程本地变量，也就是如果你创建了一个ThreadLocal变量，那么访问这个变量的每个线程都会有这个变量的一个本地副本。

当多个线程操作这个变量时，实际操作的是自己本地内存里面的变量，从而避免了线程安全问题。

创建一个TheadLocal变量后，每个线程都会复制一个变量到本地内存，如下图所示。

![image-20220413101818502](https://mygiteepic.oss-cn-shenzhen.aliyuncs.com/img/image-20220413101818502.png)

#### 16、描述下ThreadLocal的原理

Thread类中有一个`threadLocals`和一个`inheritableThreadLocals`，它们都是ThreadLocalMap类型的变量，而ThreadLocalMap是一个定制化的HashMap。

在默认情况下，每个线程中的这两个变量都为null，只有当前线程第一次调用`ThreadLocal`的set或者get方法时才会创建它们。其实每个线程的本地变量不是存放在`ThreadLocal`实例里面，而是存放在调用线程的`threadLocals`变量里面。也就是说，`ThreadLocal`类型的本地变量存放在具体的线程内存空间中。

`ThreadLocal`就是一个工具壳，它通过set方法把value值放入调用线程的`threadLocals`里面存放起来，当调用线程调用它的get方法时，再从当前线程的`threadLocals`变量里面将其拿出来使用。如果调用线程一直不终止，那么这个本地变量会一直存放在调用线程的threadLocals变量里面，所以当不需要使用本地变量时，可以通过调用ThreadLocal里面的remove()方法，从当前线程的threadLocals里面删除该本地变量。

另外，Thread里面的`threadLocals`为何设计为Map结构，很明显是因为每个线程可以关联多个ThreadLocal变量。

![image-20220413104130238](https://mygiteepic.oss-cn-shenzhen.aliyuncs.com/img/image-20220413104130238.png)

#### 17、ThreadLocal Set方法源码剖析

![image-20220413104213625](https://mygiteepic.oss-cn-shenzhen.aliyuncs.com/img/image-20220413104213625.png)

疑问：我set了2个值，为什么获取出来的只有thank1，这就引出了另外一个问题，ThreadLocal是个Map，它key是啥？目前来看thanks是被thank1覆盖掉了。看下set方法的源代码：

![image-20220413104412929](https://mygiteepic.oss-cn-shenzhen.aliyuncs.com/img/image-20220413104412929.png)

![image-20220413104612891](https://mygiteepic.oss-cn-shenzhen.aliyuncs.com/img/image-20220413104612891.png)

先获取当前线程t，然后以t为key获取当前threadLocalMap对象。如果Map存在则设置，注意设置的key为this，this代表当前对象，key不变，所以value会被覆盖。如果Map不存在则进行createMap。

#### 18、ThreadLocal支持继承吗

![image-20220413104902561](https://mygiteepic.oss-cn-shenzhen.aliyuncs.com/img/image-20220413104902561.png)

也就是说，==同一个ThreadLocal变量在父线程中被设置值后，在子线程中是获取不到的。==

根据之前题目的线程私有介绍（86题），这应该是正常现象，因为在子线程thread里面调用get方法时当前线程为thread线程，而这里调用set方法设置线程变量的是main线程，两者是不同的线程，自然子线程访问时返回null。

![image-20220413105515990](https://mygiteepic.oss-cn-shenzhen.aliyuncs.com/img/image-20220413105515990.png)

#### 19、有没有办法让子线程能访问到父线程中的threadlocal的值

为了解决上提出的问题，`InheritableThreadLocal`就来了。`InheritableThreadLocal`继承自ThreadLocal，其提供了一个特性，就是让子线程可以访问在父线程中设置的本地变量。下面看一下`InheritableThreadLocal`的代码

![image-20220413110414027](https://mygiteepic.oss-cn-shenzhen.aliyuncs.com/img/image-20220413110414027.png)

这是`InheritableThreadLocal`的全部代码，他继承了ThreadLocal，并复写了三个方法。一个是getMap，上一题有看过ThreadLocal源码，一个是createMap，上上题有看过ThreadLocal源码。

#### 20、具体说说`InheritableThreadLocal`如何让子线程访问到在父线程中设置的本地变量的

从代码上看，getMap和createMap没什么稀奇的，无非是创建和获取。这不是原理所在。

除了getMap和createMap，只能来看看chilidvalue这个方法了。我们看到的代码逻辑是`return parentValue`；

为了说清楚childValue这个方法，我们得先看Thread类得init方法：从代码可以看出，Thread初始化的时候进行了判断，如果父类的`inheritableThreadLolcas`不为空，则进行`createInheriteMap`方法创建，继续点进去看

![image-20220413112502849](https://mygiteepic.oss-cn-shenzhen.aliyuncs.com/img/image-20220413112502849.png)

![image-20220413112515063](https://mygiteepic.oss-cn-shenzhen.aliyuncs.com/img/image-20220413112515063.png)

此处调用了childValue，返回parent的value，在该函数内部把父线程inhritbIThreadLocal的值复制到新的ThreadLocalMap对象。

总结：`inheritableThreadLocal类`通过重写代码。getMap和createMap让本地变量保存到了具体线程的inheritableThreadLocals变量里面，那么线程在通过InheritableThreadLocal类实例的set或者get方法时，就会创建当前线程中的InheritableThreadLocals变量。

当父线程创建子线程时，构造函数就会把父线程中InheritableThreadLocals变量里面的本地变量复制一份保存到子线程的InheritableThreadLocals变量里面。

#### 21、说说InheritableThreadLocal的使用场景

情况还是蛮多的，比如子线程需要使用存放在threadlocal变量中的用户登录信息，再比如一些中间件需要把统一的id追踪的整个调用链路记录下来。其实子线程使用父线程中的threadLocal方法有很多种方式，比如创建线程时传入父线程中的变量，并将其复制到子线程中，或者在父线程中构造一个map作为参数传递给子线程，但是这些都改变了我们的使用习惯，所以在这些情况下InheritableThreadLocal就显得比较有用。

#### 22、程序上下文切换监测和解决办法

监测：

使用Lmbench3[1]可以测量上下文切换的时长；

使用vmstat可以测量上下文切换的次数

![image-20220413134212930](https://mygiteepic.oss-cn-shenzhen.aliyuncs.com/img/image-20220413134212930.png)

排查步骤：

1、查询java程序的进程ID

```shell
jps -l 
```

2、使用Jstack命令dump出线程文件

```shell
sudo -u admin /opt/ifeve/java/bin/jstack 31177
```

3、统计所有线程分别处于什么状态

```shell
grep java.lang.Thread.state dump17 | awk '{print $2$3$4$5}' | sort | uniq 
```

![image-20220413134633938](https://mygiteepic.oss-cn-shenzhen.aliyuncs.com/img/image-20220413134633938.png)

4、打开dump文件查看处于WAITING（onobjectmonitor)的线程在做什么

#### 23、发现程序的CPU100%，内存和IO利用率都正常，是什么原因，如何排查

原因：死锁

排查：dump线程数据

```
IDEA中排查
1、jps -l （找出要查看的进程id）
2、jstack pid

在生成环境Linux上
1、top -h 查看CPU飙高java进程
2、top -p pid  查看进程下的线程信息
3、使用jstack 进程id >/路径.dump 输出内存快照到磁盘
4、直接cat 或者是使用visualvm工具分析
5、查找的时候建议十进制pid转成16进制   pinrtf "%x\n" pid
6、分析dump快照即可
```

![image-20220413141759819](https://mygiteepic.oss-cn-shenzhen.aliyuncs.com/img/image-20220413141759819.png)

#### 23、volatile是如何保证可见性的

如：volatile instance = new instance() 

示例代码中，instance 被 volatile修饰

上边的new 操作，转化汇编代码如下

![image-20220413142015389](https://mygiteepic.oss-cn-shenzhen.aliyuncs.com/img/image-20220413142015389.png)

有volatile变量修饰的共享变量进行写操作的时候会多出第二行Lock汇编代码，Lock前缀的指令在多核处理器下会引发两件事：

==1）将当前处理器缓存行的数据写回到主内存（volatile写的内存语义）==

==2）这个写回内存的操作会使在其他CPU里缓存了该内存地址的数据无效（volatile写的内存语义）==

如果对声明了volatile的变量进行写操作，JVM就会向处理器发送一条Lock的前缀指令，将这个变量所在缓存行的数据写回到系统内存

在多处理器下，为了保证各个处理器的缓存是一致的，就会实现缓存一致性协议，每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器对这个数据进行操作的时候，会重新从系统内存中把数据读到处理器缓存里（volatile读内存语义）

#### 24、Synchronized关键字的三种使用方式

- 对于普通同步方法，锁是当前实例对象
- 对于静态同步方法，锁是当前类的Class对象
- 对于同步方法块，锁的是Synchronized括号里配置的对象
- 当一个线程试图访问同步代码块时，它首先必须得到锁，退出或者抛出异常时，必须要释放锁。

#### 25、Synchronized在JVM里的首先原理

JVM基于进入和退出Monitor对象来实现方法同步和代码同步，但两者的实现细节不一样。代码块同步是使用`monitorenter`和`monitorexit`指令来实现的，而方法同步是使用另外一种方式实现的。

`monitorenter`指令是在编译后插入到同步代码块的开始位置，而monitorexit是插入到方法结束处和异常处，JVM要保证每个monitorenter必须有对应的monitorexit与之配对

任何对象都有一个monitor与之关联，当且一个monitor被持有后，它将处于锁定状态。线程执行到monitorenter指令时，将会尝试获取对象所对应的monitor的所有权，即尝试获得对象的锁。

同步方法 public synchronized void add(){ i++;}

反编译成字节码后查看底层原理：

![image-20220413144521523](https://mygiteepic.oss-cn-shenzhen.aliyuncs.com/img/image-20220413144521523.png)

可以看到在add方法的flags里面多了一个`ACC_SYNCHRONIZED`标志，这标志用来告诉JVM这是一个同步方法。

同步代码块synchronized(this.class){i++;}

反编译成字节码后查看底层原理

![image-20220413145136072](https://mygiteepic.oss-cn-shenzhen.aliyuncs.com/img/image-20220413145136072.png)

为什么有两个monitorexit呢?

第一个：正常退出

第二个：异常退出

#### 26、Synchronized锁信息在对象中的存储位置

存储在对象的对象头（Mark Word）中。

无锁状态下32位JVM的Mark Word的默认存储结构如下：

![image-20220415173828212](https://mygiteepic.oss-cn-shenzhen.aliyuncs.com/img/image-20220415173828212.png)

有锁状态的Mark Word的信息变化如下，并从下图中能够看到锁的信息的确是放到Mark Word中的，并且有不同的锁类型，Mark Word中的信息会有变化。

![image-20220415174005540](https://mygiteepic.oss-cn-shenzhen.aliyuncs.com/img/image-20220415174005540.png)

#### 27、描述下锁的分类与锁升级

Java SE1.6为了减少获取锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁”，在JavaSE1.6中，锁一共有4种状态，级别从**低到高**依次是：==无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态==。

这几哥状态会随着竞争情况逐渐升级。**锁可以升级但不能降级**，意味着偏向锁升级成轻量级锁后不能降级成偏向锁。这种锁升级却不能降级的策略，目的是为了提高获得锁和释放锁的效率。

#### 28、偏向锁的原理

当一个线程访问同步块并获取锁时，会在==对象头和栈帧中的锁记录里存储锁偏向的线程ID==，以后该线程在进入和退出 同步块时不需要进行CAS操作来加锁和解锁，只是简单的测试一下对象头里面的Mark Word里是否 存储着指向当前线程的偏向锁。

如果测试成功，表示线程已经获取了锁

如果测试失败，则需要再测试一下Mark Word中偏向锁的标识是否设置成1（表示当前是偏向锁）

- 如果没有设置，则使用CAS竞争锁
- 如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程

#### 29、偏向锁撤销原理

偏向锁使用了一种等到竞争出现才释放锁的机制，所以当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放锁。

偏向锁的撤销，需要等待全局安全点（在这个时间点上没有正在执行的字节码）

它会首先暂停拥有偏向锁的线程，然后检查持有偏向锁的线程是否活着，如果线程不处于活动状态，则将对象头设置成无锁状态；

如果线程仍然活着，拥有偏向锁的栈会被执行，遍历偏向对象的锁记录，栈中的锁记录和对象头的Mark Word要重新偏向于其他线程，要么恢复到无锁或者标记对象不适合作为偏向锁，最后唤醒暂停的线程。

![image-20220415175758206](https://mygiteepic.oss-cn-shenzhen.aliyuncs.com/img/image-20220415175758206.png)

#### 30、JVM偏向锁能够撤销吗？

偏向锁在Java 6和Java7里是默认启用的，但是它在应用程序启动几秒后才激活，如有必要可以使用JVM参数来关闭延迟；`-XX：BiasedLockingStartupDelay=0`

如果你确定应用程序里所有的锁通常情况下处于竞争状态，可以通过JVM参数关闭偏向锁：`-XX:UseBiasedLocking=false`,那么程序默认会进入轻量级锁状态。

#### 31、轻量级的加锁和解锁过程

**轻量级锁加锁**

- 线程在执行同步块之前，JVM会先在当前线程的栈帧中创建用于存储记录的空间，并将对象头中的Mark Word复制到锁记录空间中，官方称为`Displaced Mark Word`
- 然后线程尝试使用CAS将对象头中的Mark Word 替换为指向锁记录的指针
- 如果成功，当前线程获取锁，如果失败，表示其他线程竞争锁，当前线程便尝试使用自旋来获取锁

**轻量级解锁**

会使用原子的CAS操作将`Displaced Mark Word`替换回到对象头，如果成功，则表示没有发生竞争。如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁
