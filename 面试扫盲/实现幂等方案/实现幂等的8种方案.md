## 实现幂等的8种方案

### 1、什么是幂等

幂等是一个数学与计算机科学概念。

- 在数学中，幂等用函数表达式就是：`f(x) = f(f(x))`。比如求绝对值的函数，就是幂等的，`abs(x) = abs(abs(x))`。
- 在计算机科学中，==幂等表示一次和多次请求某一个资源应该具有同样的副作用==，或者说，
- ==多次请求所产生的影响与一次请求执行的影响效果相同==。



### 2、为什么需要幂等

举个例子：

我们开发一个转账功能，假设我们调用下游接口**超时**了。一般情况下，**超时**可能是**网络传输丢包**的问题，也可能是请求时没送到，还有可能是请求到了，**返回结果却丢**了。这时候我们是否可以重试呢？如果**重试**的话，是否会多转了一笔钱呢？

![image-20220105110500901](https://gitee.com/huangwei0123/image/raw/master/img/image-20220105110500901.png)

当前互联网的系统几乎都是解耦隔离后，会存在各个不同系统的**相互远程调用**。调用远程服务会有三个状态：成功、失败、或者超时。前两者都是明确的状态，而超时则是`未知状态`。我们转账`超时`的时候，如果下游转账系统做好`幂等`控制，我们发起**重试**，==那即可保证转账正常进行，又可以保证不会多转一笔。==

其实除了转账这个例子，日常开发中，还是`很多很多例子需要考虑幂等`。比如：

- MQ（消息中间件）消费者读取消息时，有可能会读取到重复消息。**（重复消费）**
- 比如提交form表单时，如果快速点击提交按钮，可能产生了两条一样的数据**（前端重复提交）**



### 3、接口超时了，到底如何处理？

如果我们调用下游接口超时了，我们应该怎么处理呢?

有`两种方案`处理:

- 方案一：就是下游系统提供一个对应的查询接口。如果接口超时了，先查下对应的记录，如果查到是成功，就走成功流程，如果是失败，就按失败处理。

> 拿我们的转账例子来说，转账系统提供一个查询**转账记录**的接口，如果**渠道系统**调用**转账系统**超时时，**渠道系统**先去查询一下这笔记录，看下这笔转账记录成功还是失败，如果成功就走成功流程，失败再重试发起转账。

![image-20220105113626797](https://gitee.com/huangwei0123/image/raw/master/img/image-20220105113626797.png)

- 方案二：下游接口**支持幂等**，上游系统如果`调用超时`，发起重试即可。

![image-20220105113719072](https://gitee.com/huangwei0123/image/raw/master/img/image-20220105113719072.png)

两种方案都是挺不错的，但是如果是**MQ重复消费的场景**，方案一处理并不是很妥，所以，我们还是要求下游系统**对外接口支持幂等**。



### 4、如何设计幂等

既然这么多场景需要考虑幂等，该如何去设计？

幂等意味着一条请求的唯一性。不管是你哪个方案去设计幂等，==都需要一个`全局唯一的ID`==，去标记这个请求是独一无二的。

- 如果你是利用唯一索引控制幂等，那唯一索引是唯一的。
- 如果你是利用数据库主键来控制幂等，那主键是唯一的。
- 如果你是用悲观锁的方式来控制，底层标记还是**全局唯一的ID**

#### 4.1 全局的唯一性ID

全局唯一性ID，我们怎么去生成呢？你可以回想下，数据库主键Id，怎么生成的呢？

1、我们可以使用`UUID`，但是UUID的缺点比较明显，它的字符串占用的空间比较大，生成的ID过于随机，可读性差，而且没有顺序性（没有递增）

2、使用雪花算法生成唯一性ID。雪花ID有64位

- 第一位：java中long的最高位表示正负，正数是0，负数是1，一般生成ID都为正数，所以默认为0
- 接下来前41位是时间戳，表示自选定的时期以来的毫秒数
- 接下来10位代表计算机ID，防止冲突
- 其余12位代表每台机器上生成ID的序列号，这允许在同一毫秒内创建多个雪花ID

![image-20220105150553556](https://gitee.com/huangwei0123/image/raw/master/img/image-20220105150553556.png)

当然，全局唯一性的ID，还可以使用百度的`Uidgenerator`，或者美团的`Leaf`

#### 4.2 幂等设计的基本流程

幂等处理的过程，说到底就是过滤以下已收到的请求，当然，请求一定要有一个`全局唯一ID标记`。然后，

==怎么判断请求是否是之前收到过呢?把请求存储起来，收到请求时，先查下存储记录，记录存在就返回上次的结果，不存在就处理请求。==

一般的幂等处理就是这样啦，如下：

![image-20220105204615668](https://gitee.com/huangwei0123/image/raw/master/img/image-20220105204615668.png)

### 5、实现幂等的8种方案

幂等设计的基本流程都是类似的，我们过一下幂等实现的8中方案

#### 5.1 select + insert + 主键/唯一索引冲突

日常开发中，为了实现交易接口的幂等，一般这样实现：

交易请求过来，会先根据请求的`唯一流水号bizSequence`字段，先`select `下数据库的流水表

- 如果数据已经存在，就拦截是重复请求，直接返回成功。
- 如果数据不存在，就执行`insert`插入，如果`insert`插入成功，则之间返回成功，如果`insert`插入主键冲突异常，则捕获异常，接着之间返回成功。

整个流程如下：

![image-20220105205157468](https://gitee.com/huangwei0123/image/raw/master/img/image-20220105205157468.png)

伪代码如下：

```java
/**
 * 幂等处理
 */
Rsp idempotent（Request req）{
    Object requestRecord =selectByBizSeq（bizSeq）;

    if(requestRecord !=null){
        //拦截是重复请求
        log.info("重复请求，直接返回成功，流水号：{}",bizSeq);
        return rsp;
    }

    try{
        insert(req);
    }catch(DuplicateKeyException e){
        //拦截是重复请求，直接返回成功
        log.info("主键冲突，是重复请求，直接返回成功，流水号：{}",bizSeq);
        return rsp;
    }

    //正常处理请求
    dealRequest(req);

    return rsp;
}
```

