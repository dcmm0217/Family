# 单例模式（上）：为什么说支持懒加载的双重检测不比饿汉式更优？

重点搞清楚下面这样几个问题（第一个问题会在今天讲解，后面三个问题放到下一节课中讲解）。

- 为什么要用单例？
- 单例存在哪些问题？
- 单例与静态类的区别？
- 有何替代的解决方案？

## 1、为什么要使用单例？

单例设计模式（Singleton Design Parttern）理解起来非常简单。**一个类只允许创建一个对象（或者实例），那这个类就是一个单例类，这种设计模式就叫作单例设计模式，简称单例模式。**

对于单例的概念，我觉得没必要解释太多，你一看就能明白。我们重点看一下，为什么我们需要单例这种设计模式？它能解决哪些问题？接下来通过2个实战案例讲解。

#### **实战案例一：处理资源访问冲突**

在这个例子中，我们自定义实现了一个往文件中打印日志的Logger 类。具体的代码实现如下所示：

```java
public class Logger{
    private FileWriter writer;

    public Logger() {
        File file = new File("/Users/wangzheng/log.txt");
        writer = new FileWriter(file, true); //true表示追加写入
    }

    public void log(String message) {
        writer.write(mesasge);
    }
}

// Logger类的应用示例：
public class UserController {
    private Logger logger = new Logger();
    public void login(String username, String password) {
        // ...省略业务逻辑代码...
        logger.log(username + " logined!");
    }

}

public class OrderController {
    private Logger logger = new Logger();

    public void create(OrderVo order) {
        // ...省略业务逻辑代码...
        logger.log("Created an order: " + order.toString());
    }
}
```

看完代码之后，先别着急看我下面的讲解，你可以先思考一下，这段代码存在什么问题。

在上面的代码中，我们注意到，所有的日志都写入到同一个文件/Users/wangzheng/log.txt 中。在 UserController 和 OrderController 中，我们分别创

建两个 Logger 对象。在 Web 容器的 Servlet 多线程环境下，如果两个 Servlet 线程同时分别执行 login() 和 create() 两个函数,并且同时写日志到 log.txt 文件中，那就有可能存在日志信息互相覆盖的情况。

**为什么会出现互相覆盖呢？**

我们可以这么类比着理解。在多线程环境下，如果两个线程同时给同一个共享变量加 1，因为共享变量是竞争资源，所以，共享变量最后的结果有可能并不是加了 2，而是只加了 1。同理，这里的 log.txt 文件也是竞争资源，两个线程同时往里面写数据，就有可能存在互相覆盖的情况。