# 策略模式

#### 1、策略模式的定义

**定义一组算法，将每个算法都封b装起来，并且使他们之间可以互换。**

为什么可以互换？

都是实现的相同的接口，当然可以互换。

**策略模式的通用类图**

![image-20221216171436923](https://mygiteepic.oss-cn-shenzhen.aliyuncs.com/img/image-20221216171436923.png)

策略模式使用的就是面向对象的继承和多态机制，非常容易理解和掌握，我们再来看看策略模式的三个角色

- Context封装角色

**它也叫做上下文角色，起承上启下封装作用，屏蔽高层模块对策略、算法的直接访问，封装可能存在的变化。**

- Strategy抽象策略角色

**策略、算法家族的抽象，通常为接口，定义每个策略或算法必须 具有的方法和属性。**

- ConcreteStrategy具体策略角色

实现抽象策略中的操作，该类含有具体的算法。

- 高层模块调用的角色

具体去调用，以及如何情况去选择什么样的策略的角色



#### 2、策略模式的实现

**先看抽象策略角色，它是一个非常普通的接口，在我们的项目中就是一个普通得不能 再普通的接口了，定义一个或多个具体的算法**

抽象的策略角色

```java
public interface Strategy {
    //策略模式的运算法则
    public void doSomething();
}
```

具体策略也是非常普通的一个实现类，只要实现接口中的方法就 可以

具体策略角色

```java
public class ConcreteStrategy1 implements Strategy {
    public void doSomething() {
        System.out.println("具体策略1的运算法则");
    }
}
public class ConcreteStrategy2 implements Strategy {
    public void doSomething() {
        System.out.println("具体策略2的运算法则");
    }
}
```

策略模式的重点就是封装角色，它是借用了**代理模式的思路**，大家可以想想，它和代理模式有什么差别，

**差别就是策略模式的封装角色和被封装的策略类不用是同一个接口，如果是同一个接口那就成为 了代理模式。**

我们来看封装角色

```java
public class Context {
    //抽象策略
    private Strategy strategy = null; 
    //构造函数设置具体策略
    public Context(Strategy _strategy){
        this.strategy = _strategy;
    }
    //封装后的策略方法
    public void doAnythinig(){
        this.strategy.doSomething();
    }
}
```

高层模块的调用非常简单，知道要用哪个策略，产生出它的对象，然后放到封装角色中就完成任务了

```java
public class Client {
    public static void main(String[] args) {
        //声明一个具体的策略
        Strategy strategy = new ConcreteStrategy1();
        //声明上下文对象
        Context context = new Context(strategy);
        //执行封装后的方法
        context.doAnythinig();
    }
}
```

策略模式就是这么简单，偷着乐吧，它就是采用了面向对象的继 承和多态机制，其他没什么玄机。想想看，你真实的业务环境有这么简单吗？

一个类实现多个接口很正常，你要有火眼金睛看清楚哪个接口是抽象策略接口，哪些是和策略模式没有任何关系，这就是你作为 系统分析师 的价值所在。



#### 3、策略模式的应用

优点：

- 算法可以自由的切换

这是策略模式本身定义的，只要实现抽象策略，它就成为策略家族的一个成员，通过封装角色对其进行封装，保证对外提供”可自由切换“的策略

- 避免使用多重条件判断

如果没有策略模式，我们想想看会是什么样子？一个策略家族有5 个策略算法，一会要使用A策略，一会要使用B策略，怎么设计呢？使 用多重的条件语句？

多重条件语句不易维护，而且出错的概率大大增强。使用策略模式后，可以由其他模块决定采用何种策略，策略家族 对外提供的访问接口就是封装类，简化了操作，同时避免了条件语句判断。

- 扩展性良好

这甚至都不用说是它的优点，因为它太明显了。在现有的系统中 增加一个策略太容易了，只要实现接口就可以了，其他都不用修改， 类似于一个可反复拆卸的插件，这大大地符合了OCP原则（开闭原则）。

开闭原则：软件实体（包括类、模块、功能等）应该，对修改关闭，对扩展开放。

缺点：

- 策略类增多

每一个策略都是一个类，复用的可能性很小，类数量增多。

- 所有的策略类都是需要对外暴露

上层模块必须知道有哪些策略，然后才能决定使用哪一个策略， 这与迪米特法则是相违背的，我只是想使用了一个策略，我凭什么就 要了解这个策略呢？那要你的封装类还有什么意义？这是原装策略模 式的一个缺点，幸运的是，我们可以使用其他模式来修正这个缺陷， 如工厂方法模式、代理模式或享元模式。



#### 4、策略模式的使用场景

-  多个类只有在算法或行为上稍有不同的场景。
- 算法需要自由切换的场景。

算法的选择是由使用者决定的，或者算法始终在进化，特 别是一些站在技术前沿的行业，连业务专家都无法给你保证这样的系 统规则能够存在多长时间，在这种情况下策略模式是你最好的助手。

-  需要屏蔽算法规则的场景

现在的科技发展得很快，人脑的记忆是有限的（就目前来说是有 限的），太多的算法你只要知道一个名字就可以了，传递相关的数字 进来，反馈一个运算结果，万事大吉

**注意点：**如果系统中的一个策略家族的具体策略数量超过4个，则需要考虑 使用混合模式，解决策略类膨胀和对外暴露的问题，否则日后的系统 维护就会成为一个烫手山芋，谁都不想接



#### 5、策略模式的扩展

策略枚举的使用

```java
public enum Calculator {
    //加法运算
    ADD("+"){
        public int exec(int a,int b){
            return a+b;
        }
    },
    //减法运算
    SUB("-"){
        public int exec(int a,int b){
            return a - b;
        }
    };
    String value = "";
    //定义成员值类型
    private Calculator(String _value){
        this.value = _value;
    }
    //获得枚举成员的值
    public String getValue(){
        return this.value;
    }
    //声明一个抽象函数
    public abstract int exec(int a,int b);
}

```

调用场景类

```java
public class Client {
    public static void main(String[] args) {
        //输入的两个参数是数字
        int a = Integer.parseInt(args[0]);
        String symbol = args[1]; //符号
        int b = Integer.parseInt(args[2]);
        System.out.println("输入的参数为："+Arrays.toString(args));
        System.out.println("运行结果为："+a+symbol+b+"="+Calculator.ADD.exec(a,b));
    }
}

```

运行结果与方案一相同。看这个场景类，代码量非常少，而且还有一个显著的优点：真实地面 向对象，看看这条语句： Calculator.ADD.exec(a, b) 是不是类似于“拿出计算器（Calculator），对a和b进行加法运算（ADD），并立刻执行(exec)”， 这与我们日常接触逻辑是不是非常相似，这也正是我们架构师要担当的职责！

注意: **策略枚举是一个非常优秀和方便的模式，但是它受枚举类型的限制，每个枚举项都是 public、final、static的，扩展性受到了一定的约束，因此在系统开发中，策略枚举一般担当不经常发生变化的角色。**

#### 6、策略模式最佳实践

策略模式是一个非常简单的模式。**它在项目中使用得非常多，但它单独使用的地方就比较少了，因为它有致命缺陷：所有的策略都需 要暴露出去，这样才方便客户端决定使用哪一个策略。**

例如，在例子 中的赵云，实际上不知道使用哪个策略，他只知道拆第一个锦囊，而 不知道是BackDoor这个妙计。是的，诸葛亮已经在规定了在适当的场 景下拆开指定的锦囊，我们的策略模式只是实现了锦囊的管理，

但是 **我们没有严格地定义“适当的场景”拆开“适当的锦囊”，在实际项目 中，我们一般通过工厂方法模式来实现策略类的声明，读者可以参考 混编模式。**